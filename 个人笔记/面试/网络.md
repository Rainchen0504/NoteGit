## 1、GET和POST请求区别

### （1）应用场景

GET请求是一个幂等的请求。一般GET请求用于<font color=pink>对服务器资源不会产生影响的场景</font>，比如说请求一个网页的资源。

POST不是一个幂等的请求。一般用于<font color=pink>对服务器资源会产生影响的情景</font>，比如用户注册这一类操作。

幂等是指一个请求方法多次执行和仅执行一次的效果完全相同。

### （2）是否缓存

浏览器一般会对 GET 请求缓存，但很少对 POST 请求缓存。

### （3）传参方式不同

GET 通过查询字符串传参，POST 通过请求体传参。

### （4）安全性

GET 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 POST 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。

### （5）请求长度

浏览器由于对 url 长度的限制，所以会影响 GET 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。

### 补充⚠️：GET请求URL长度限制原因

IE浏览器队URL长度限制是**2083字节**，忧郁IE浏览器对URL长度的允许值是**最小的**，因此只要URL不超过2083字节，其他浏览器就不会有问题。

### （6）参数类型

GET 请求只允许ASCII字符，POST 的参数传递支持更多的数据类型(如文件、图片)。



## 2、常见HTTP请求头和响应头

### （1）请求头Request Header

- Accept：浏览器能够处理的内容类型
- Accept-Charset：浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookie：当前页面设置的任何Cookie
- Host：发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

### （2）响应头Responses Header

- Date：表示消息发送的时间
- server：服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache-Control：控制HTTP缓存
- Content-Type：表示后面的文档属于什么类型



## 3、常见内容类型content-type

### （1）application/x-www-form-urlencoded

​	浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

### （2）multipart/form-data

该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

### （3）application/json

服务器消息主体是序列化后的 JSON 字符串。

### （4）text/xml

该种方式主要用来提交 XML 格式的数据。



## 4、常见HTTP请求方法

GET：向服务器获取数据；

POST：发送数据给服务器，通常会造成服务器资源的新增修改；

PUT：创建一个新的资源或用请求的参数资源替换目标资源；

DELETE：删除指定资源；

PATCH：对资源进行部分修改；

HEAD：获取报文首部，与GET相比，不返回报文主体部分；使用场景是比如下载一个大文件前，先获取其大小再决定是否要下载，以此可以节约宽带资源；

TRACE：沿着通往目标资源的路径进行信息回环测试，提供一个有用的调试机制；

CONNECT：要求在与代理服务器通信时建立**管道**，使用**管道**进行TCP通信；(把服务器作为跳板，让服务器代替用户去访问其他网页，之后把数据原原本本的返回给用户)

OPTIONS：(浏览器自动执行)、询问支持的请求方法，用来跨域请求、预检请求、判断目标是否安全



## 5、AJAX

### （1）发送请求

ajax就是用js发送异步的网络请求；

A--Asynchronous 异步；J--Javascript；A--And；X--XML与XMLHttpRequest；

```js
// 创建实例化ajax对象
let xhr = new XMLHttpRequest()
// 设置请求方法和地址
xhr.open("post","http://www.liulongbin.top:3309/api/login")
// 设置请求头（post请求才需要设置）
 xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
// 发送请求
xhr.send("username=admin&password=123456")
// 回调函数
xhr.onreadstatechange = function () {
  if (xhr.readState == 4 && xhr.status == 200) {
    console.log(xhr.responseText)
  }
}
```

### （2）取消请求方法

1. 原生取消请求

   ```js
   var xhr = new XMLHttpRequest();
   xhr.abort(); // 取消请求方法
   ```

2. axios取消请求

   1. 使用 CancelToken.source 工厂方法创建 cancel token

      ```js
      const CancelToken = axios.CancelToken;
      const source = CancelToken.source();
      axios.get('/user/123', {
          cancelToken: source.token
      }).catch(function(thrown) {
          if (axios.isCancel(thrown)) {
              console.log('Request canceled', thrown.message);
          } else {
          // 处理错误
          }
      });
      axios.post('/user/123', {
          name: '小明'
      }, {
          cancelToken: source.token
      }) dd 
      // 取消请求（message 参数是可选的）
      source.cancel('canceled by the user'); 
      ```

   2. 传递一个executor函数到CancelToken的构造函数来创建cancel token

      ```js
      const CancelToken = axios.CancelToken;
      let cancel;
      axios.get('/user/12345', {
        cancelToken: new CancelToken(function executor(c) {
          // executor 函数接收一个 cancel 函数作为参数
          cancel = c;
        })
      });
      // cancel the request
      cancel();
      ```

3. 取消请求的意义

   1. 已发出的请求可能仍然会到达后端；
   2. 取消后续的回调处理，避免多余的回调处理（先发出的后返回，导致回调中的数据错误覆盖）
   3. 取消loading效果，以及该请求的其他交互效果，特别是在单页应用中，A页面跳转到B页面之后，A页面的请求应该取消，否则回调中的一些处理可能影响B页面；
   4. 超时处理，错误处理等都省去了，节约资源；



## 6、HTTP1.0、HTTP1.1、HTTP2.0和HTTP3.0

### （1）1.0和1.1的区别

#### 1.1、连接方面

http1.0默认使用非持久连接，而1.1默认使用持久连接。http1.1通过使用持久连接来使多个http请求复用同一个TCP连接，从而避免使用非持久连接时每次需要建立连接的延时。

#### 1.2、资源请求方面

在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206，这样就方便了开发者自由的选择以便于充分利用带宽和连接。

#### 1.3、缓存方面

在 http1.0 中主要使用 header 里的 If-Modified-Since（标识符-协商缓存）、Expires（缓存到期时间-强缓存） 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。

#### 1.4、http1.1新增host字字段

用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。

#### 1.5、请求方法方面

新增PUT、HEAD、OPTIONS等请求方法。



### （2）1.1和2.0的区别

#### 2.1、二进制协议

HTTP/2是一个二进制协议，1.1中报文头信息必须是文本(ASCII编码)，数据体可以是文本、也可以是二进制。HTTP/2则是一个彻底的二进制协议，头信息和数据体都是二进制统称为“帧”，可以分为头信息帧和数据帧。

#### 2.2、多路复用

HTTP/2实现了多路复用，HTTP/2仍复用TCP连接，但是在一个连接中，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序发送，避免队头堵塞问题。

#### 2.3、数据流

 HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。

#### 2.4、头信息压缩

HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，同样的内容，每次请求都必须附带，会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息**使用 gzip 或 compress 压缩后再发送**；另一方面，**客户端和服务器同时维护一张头信息表**，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。

#### 2.5、服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。



### （3）HTTP3.0

HTTP3.0核心是QUIC协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层UDP上的协议，该协议实现了类似TCP的流量控制、传输可靠性功能；集成了TLS加密功能；实现了HTTP/2中的多路复用功能；实现了快速握手能力；



## 7、队头堵塞

### （1）说明

队头堵塞是HTTP基本的“请求-应答”模型导致的。HTTP规定报文必须是“一发一收”，因此形成一个先进先出的“串行”队列。队列中请求是没有优先级的，只有入队的先后顺序，排在最前面的会被优先处理。如果队首发生丢包或延时的情况，队列中所有请求都会跟着一起等待，增加了其他请求的时间成本，造成队头堵塞现象。

### （2）解决方法

- 并发连接：对于一个域名允许分配多个长连接，相当于增加了任务队列，避免一个任务堵塞其他所有任务；
- 域名分片：将域名分出多个二级域名，指向同一台服务器，能够并发的长连接变多，解决队头堵塞问题；



## 8、HTTP和HTTPS区别

1. HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密，相对更安全；
2. HTTP和HTTPS使用连接方式不同，默认端口源也不一样，HTTP是80端口，HTTPS是443；
3. HTTPS由于需要涉及加密和多次握手，性能不如HTTP；
4. HTTPS需要SSL加密，SSL证书需要钱，功能越强大费用越高；



## 9、HTTP优缺点

​	HTTP是超文本传输协议，定义了<font color=blue>客户端和服务器之间交换报文的格式和方式</font>，默认使用80端口，<font color=blue>使用TCP作为传输层协议</font>，保证数据传输的可靠性。

### （1）优点

- 支持客户端/服务器模式；

- **简单快速**。客户向服务器请求服务时，只需传送请求方法和路径，HTTP服务规模小，通信速度很快；

- **无连接**。限制每次连接只处理一个请求，服务器处理完客户的请求并收到客户应答后，断开连接，节省传输时间；

- **无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息，在服务器不需要先前信息时它的应答就比较快；

  **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记；

### （2）缺点

- **无状态**。HTTP是一个无状态协议，HTTP服务器不会保存关于客户的任何信息，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大；
- **明文传输**。协议中的报文使用的是文本形式，直接暴漏给外界，不安全；
- **不安全**。



## 10、HTTP加载多张图片的表现

在HTTP1下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取次数。

在HTTP2下，可以一瞬间加载出很多资源，因为HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。



## 11、HTTP请求报文

请求报文由4部分组成：

- 请求行
  - 请求方法字段、URL字段、HTTP协议版本字段，使用空格分隔，如`GET/index.html HTTP/1.1`。
- 请求头部
  - 请求头部由关键字/值对组成，每行一对，关键字和值用冒号分隔
    - User-Agent：产生请求的浏览器类型；
    - Accept：客户端可识别的内容类型列表；
    - Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
- 空行
- 请求体
  - post、put等请求携带的数据



## 12、HTTP响应报文

响应报文由4部分组成：

- 响应行
  - 由网络协议版本，状态码和状态码原因短语组成，如`HTTP/1.1 200 OK`。
- 响应头
  - 响应部首组成
- 空行
- 响应体
  - 服务器相应的数据



## 13、HTTP两种连接模式

HTTP协议基于TCP/IP，并使用了**请求-应答**的通信模式。

HTTP协议有两种连接模式，<font color=pink>一种是持续连接，一种是非持续连接</font>。

- 非持续连接是服务器必须为每一个请求的对象建立和维护一个全新的连接；
- 持续连接TCP连接默认不关闭，可以被多个请求复用，相对非持续连接可以节约每次建立TCP连接三次握手所花费的时间。



## 14、TCP三次握手四次挥手

### （1）三次握手

- 第一次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；
- 第二次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；
- 第三次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。

### （2）四次挥手

- 第一次挥手：客户端发送一个FIN，关闭客户端到服务端的数据传送，客户端进入等待远端TCP连接终止请求状态；
- 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，进入等待本地用户啊连接终止请求状态；
- 第三次挥手：服务端发送一个FIN，关闭服务端到客户端的数据传送，服务端进入等待先前发送给远端TCP连接终止请求的确认状态；
- 第四次挥手：客户端收到FIN，等待服务端终止TCP连接，发送一个ACK给服务端，服务端进入不连接状态，完成四次挥手；



## 15、URL的组成

1. 协议部分：HTTP或HTTPS
2. 域名部分：可以是域名也可以是IP地址
3. 端口部分：跟在域名后面，可以省略，HTTP默认是80，HTTPS默认是443
4. 虚拟目录部分：从域名后第一个/到最后一个/为止
5. 文件名部分
6. 锚部分：从#开始到最后
7. 参数部分：从？到#之间的部分



## 16、HTTP的keep-alive

**http1.0默认关闭缓存**，需要手动开启，**http1.1之后默认开启**。

### （1）作用

使客户端到服务器端的链接持续有效（长连接），当出现对服务器的后续请求时，keep-Alive功能避免了重新建立链接；

### （2）使用方法

在请求头中加上`Connection:keep-alive`；

### （3）优点

较少的CPU和内存的占用；减少了后续请求的延迟；

### （4）缺点

 本来可以释放的资源仍旧被占用。有的请求已经结束了，但是还一直连接着；

### （5）解决方法

服务器设置过期时间和请求次数，超过这个时间或者次数就断掉连接。



## 17、缓存相关的HTTP请求头

### （1）强缓存

Expires、Cache-Control



### （2）协商缓存

Etag、If-None-Match

Last-Modified、If-Modified-Since



## 17、OSI网络七层模型

ISO于1978年开发的一套标准架构ISO模型，被引<font color=deepred>用来说明**数据通信协议的结构和功能**</font>：

网络群组：物理层、数据链路层、网络层

使用者群组：传输层、会话层、表示层、应用层

|      | OSI七层模型 | TCP/IP四层模型 | 对应网络协议                                                 |
| ---- | ----------- | -------------- | :----------------------------------------------------------- |
| 7    | 应用层      | 应用层         | `HTTP`、`RTSP` `TFTP（简单文本传输协议）、`FTP`、` NFS`（数域筛法，数据加密）、`WAIS`（广域信息查询系统） |
| 6    | 表示层      | 应用层         | `Telnet`（internet远程登陆服务的标准协议）、`Rlogin`、`SNMP`（网络管理协议）、Gopher |
| 5    | 会话层      | 应用层         | `SMTP`（简单邮件传输协议）、`DNS`（域名系统）                |
| 4    | 传输层      | 传输层         | `TCP`（传输控制协议）、`UDP`（用户数据报协议））             |
| 3    | 网络层      | 网络层         | `ARP`（地域解析协议）、`RARP`、`AKP`、`UUCP`（Unix to Unix copy） |
| 2    | 数据链路层  | 数据链路层     | `FDDI`（光纤分布式数据接口）、`Ethernet、Arpanet、PDN`（公用数据网）、`SLIP`（串行线路网际协议）`PPP`（点对点协议，通过拨号或专线方建立点对点连接发送数据） |
| 1    | 物理层      | 物理层         | `SMTP`（简单邮件传输协议）、`DNS`（域名系统）                |



## 17、



## 15、DNS

域名系统，万维网上作为域名和IP地址相互映射的一个分布式数据库，能够通过域名得到该域名对应的IP地址，而这个过程叫做域名解析；

### 查询过程

1. 搜索浏览器自身的DNS缓存，存在就返回，解析结束；
2. 如果没有缓存，就尝试读区操作系统的hosts文件查看是否存在对应映射关系，如果存在就返回，解析结束；
3. 如果hosts文件不存在映射关系，则查找本地DNS服务器，如果存在域名解析完成；
4. 如果本地DNS服务器还没找到的话，就向服务器发送请求，进行递归查询；



## 14、为什么post请求会发送两次

- 第一次请求为`options`预检请求，状态码为204。
  - 作用1：询问服务器是否支持修改的请求头，如果服务器支持，在二次中发送真正请求；
  - 作用2：检测服务器是否为同源请求，是否支持跨域；

- 第二次为真正的`post`请求。



## 16、CDN

​	`Content Delivery NetWork`——内容分发网络。用户在浏览网站的时候，CDN 会选择一个离用户最近的 CDN 边缘节点来响应用户的请求，这样海南移动用户的请求就不会                                                                                                                          千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上。

**优点**：

1. 解决了跨运营商和跨地域访问的问题，访问延时大大降低。
2. 大部分请求在CDN边缘节点完成，CDN起到分流作用，减轻源服务器的负载。
