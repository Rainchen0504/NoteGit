# 一、宏观视角下的浏览器

## 1、chrome架构

### （1）线程和进程

​	计算机中的并行处理就是同一时刻处理多个任务，使用并行处理能大大提升性能。

​	多线程可以并行处理任务，但是<font color=orange>线程是不能单独存在的，它是由进程来启动和管理的</font>。

​	**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个**运行环境叫进程**。

​	线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

#### 进程和线程之间的关系特点：

- 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
- 线程之间共享进程中的数据。
- 当一个进程关闭之后，操作系统会回收进程所占用的内存。
- 进程之间内容相互隔离。



### （2）目前浏览器的多进程架构

![image-20220324112251124](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203241122685.png)

目前的Chrome浏览器包括：**1个浏览器主进程、1个GPU进程、1个网络进程、多个渲染进程和多个插件进程**。

逐个分析下每个进程的作用：

##### 1浏览器主进程：

​	主要负责页面显示、用户交互、子进程管理，同时提供存储等功能。

##### 2渲染进程：

​	核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。包含<font color=orange>**排版引擎Blink**</font>和<font color=orange>**JS引擎V8**</font>。默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在**沙箱模式**下。

##### 3GPU进程：

​	网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。

##### 4网络进程：

​	主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

##### 5插件进程：

​	主要是负责插件的运行，因插件容易崩溃，所以需通过插件进程来隔离，保证插件进程崩溃不会对浏览器和页面造成影响。



未来浏览器的发展方向是面向服务的架构。



## 2、TCP协议

​	互联网实际上是一套**理念和协议**组成的体系架构。互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。

如何保证**页面文件能被完整地送达浏览器**，从数据包的视角分析如下：

### （1）IP：把数据包送达目的主机

​	数据包要在互联网上进行传输，得符合**<font color=orange>网际协议（简称IP）</font>**标准。互联网上不同的在线设备都有唯一的地址，地址只是一个数字。

​	**计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。**

从主机A给主机B发数据包，回加上IP头，包含IP版本、源IP地址、目标IP地址、生存时间等信息。

![image-20220325154045519](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203251618532.png)



### （2）UDP：数据包送达应用程序

​	IP只负责把数据包送到对方电脑，不负责到程序。因此需要能和应用交互的协议，常用的是**<font color=orange>用户数据包协议</font>**，简称UDP。

​	**IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。**端口号也会被装进UDP头里面。

![image-20220325162903099](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203251629556.png)

 UDP 不能保证数据可靠性，但是传输速度却非常快。所以UDP常用在线视频或互动游戏领域。



### （3）TCP：数据完整送达应用程序

UDP传输存在以下两个问题：

- 数据包运输中容易丢失；
- 大文件会拆分成小数据包，这些小数据包会在不同时间到达接收端，UDP无法还原文件；

​    基于以上两点，引入了TCP：**TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。**

​	TCP对比UDP有以下两个特点（1）TCP具有重传机制防止丢包；（2）TCP引入数据包排序机制，保证大数据包还原。

TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

![image-20220325164242070](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203251642688.png)



### （4）完整的TCP连接过程

建立连接——>传输数据——>断开连接

![image-20220325164516231](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203251645494.png)

- **建立连接阶段**：建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立，也称为三次握手。

- **数据传输阶段**：接收端需要对每个数据包进行确认操作，并发送确认数据包给发送端，如果在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同时，一个大的文件被拆分成很多小的数据包，到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
- **断开连接阶段**：传输完毕后进行四次挥手保证双方都断开连接。

TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。



## 3、HTTP请求流程

​	HTTP协议是建立在TCP基础上的。**<font color=orange>HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础</font>**，**HTTP 也是浏览器使用最广的协议**。

### （1）浏览器发起请求流程

#### 	1.构建请求

浏览器构建请求行信息，构建好后浏览器准备发起网络请求。

```js
GET /index.html HTTP1.1
```

#### 	2.查找缓存

​	请求前，浏览器会先在浏览器缓存中查询请求的文件，如果存在，拦截请求，返回该资源副本并直接结束请求。如果不存在，则会进入网络请求过程。

- 缓解服务器压力，提升性能，减少获取资源时长；
- 网站快速加载资源；

####     3.IP地址和端口

​	HTTP 的内容是通过 TCP 的传输数据阶段来实现的

![image-20220326195140455](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203261951300.png)

但是IP地址是数字标识不好记，所以衍生出一种服务，负责把域名和IP地址之间创建映射关系。这套域名映射IP的系统叫做**<font color=orange>域名系统</font>**，又称**DNS**。

拿到IP要获取端口号，如果URL没指名端口号，那么HTTP协议默认是80端口。

#### 	4.等待TCP队列

​	Chrome机制中，同一个域名同时最多只能建立6个TCP连接，超过部分会进入排队等待状态。如果小于6，则会建立TCP连接。

#### 	5.建立TCP连接

#### 	6.发送HTTP请求

TCP连接建立后，浏览器和服务器就可以进行通信，HTTP数据就在这个过程中传输的。

HTTP请求的数据格式如下：

![image-20220326234603631](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203262347727.png)

### （2）服务器端处理请求流程

#### 	1.返回请求

服务器响应数据格式如下：

![image-20220326235210712](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203281519205.png)

- 响应行包含**协议版本**和**状态码**。（200成功，404找不到页面等）。

- 响应头包含服务器信息及cookie等信息。

- 响应体包含HTML内容。	

#### 	2.断开连接

一旦服务器向客户端返回了数据就要关闭TCP连接。如果浏览器或服务器在头信息加入了

```js
Connection:Keep-Alive
```

那么TCP连接在发送后仍保持打开状态，可以继续通过同一个 TCP 连接发送请求。

**保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。**

#### 	3.重定向

相应行状态码是301，就是需要重定向到相应头中Location字段中的网址。

### （3）页面加载缓存

​	第二次打开页面比第一次快的原因是第一次页面加载过程中缓存了一些耗时的数据。

​	**<font color=orange>DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。</font>**

#### 	1.DNS缓存

主要就是在浏览器本地把对应的 IP 和域名关联起来；

#### 	2.浏览器资源缓存

缓存查找的流程示意图如下：

![image-20220327000352073](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203281518524.png)

​	服务器返回HTTP相应头给浏览器时，浏览器**<font color=orange>通过响应头中的 Cache-Control 字段来设置是否缓存该资源</font>**。通常使用**属性Max-age**参数来设置过期时间，过期时间内再请求资源会返回缓存中的资源给浏览器。

​	当缓存过期时，浏览器会继续发起网络请求，在HTTP请求头中携带If-None-Match属性，服务器会根据该属性的值判断请求资源是否更新。

#### 	3.保存登陆信息

- 打开登陆页，调用post请求给服务器发送登陆信息。
- 服务器查验登陆信息，生成用户身份字符串，并写入到相应头`Set-Cookie`字段中。
- 浏览器接受相应，相应头有Cookie时把字段信息保存到本地。
- 再次访问时，发起HTTP请求，浏览器先读取Cookie数据，并把数据写进请求头Cookie中，发送给服务器。
- 服务器接受请求头，提取Cookie字段，后台查询判断登陆信息，然后返回请求数据给浏览器。
- 浏览器正常渲染。



### （4）HTTP请求阶段总结

![image-20220328152027868](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203281520039.png)



## 4、导航流程

##### **<font color=red>常见高频面试题：从输入URL到页面展示发生了什么</font>**

### （1）首先看示意图

![image-20220328194928689](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203281949310.png)

浏览器进程、渲染进程、网络进程的职责：

- 浏览器进程负责用户交互、子进程管理和文件存储；
- 网络进程面向渲染和浏览器进程提供网络下载功能；
- 渲染进程把下载的资源解析为显示和交互页面；

结合示意图，描述如下：

- 首先，浏览器进程收到URL，转发给网络进程；
- 然后，在网络进程中发起真正的URL请求；
- 接着，网络进程收到响应头数据，并转发给浏览器进程；
- 浏览器进程收到响应头数据后，发送"提交导航"消息到渲染进程；
- 渲染进程收到"提交导航"消息后，开始直接和网络进程建立数据管道，接收HTML数据；
- 渲染进程向浏览器进程"确认提交"，准备接受和解析数据；
- 浏览器进程接收到渲染进程的"提交"消息后，移除之前的旧提交，更新页面状态；

**<font color=orange>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。</font>**



### （2）详细说明从URL到页面展示

#### 	1.用户输入

​	当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是**搜索内容**，还是**请求的 URL**。

#### 	2.URL请求过程

​	首先，网络进程会查找本地缓存是否缓存了该资源。如果有，直接返回资源给浏览器进程；如果没有，直接进入网络请求流程。

​	请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。

​	接着利用 IP 地址和服务器建立 TCP 连接。连接建立后，浏览器端构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

​	服务器接收到请求信息后，根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。

​	等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。

##### 	（1）重定向

​	网络进程接收响应头后解析，返回状态码是301或302时，说明服务器需要浏览器重定向到其他 URL。网络进程会从响应头Location字段取出重定向地址，重新发起HTTP或HTTPS请求。

##### 	（2）响应数据类型处理

浏览器通过响应头中Content-Type字段来判断响应体数据类型，然后根据具体的值来显示。

- 如果是text/html，服务器返回的数据是 HTML 格式；
- 如果是application/octet-stream，服务器返回的是字节流类型，浏览器按照下载类型处理；

#### 	3.准备渲染进程

​	Chrome默认给每个页面开启一个渲染进程，但是某些情况下会让多个页面在同一个渲染进程中。

​	Chrome 的默认策略是，每个标签对应一个渲染进程。但**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。**

注意⚠️：**<font color=orange>同一站点</font>**：**根域名**（例如，geekbang.org）加上**协议**（例如，https:// 或者 http://），还**包含了该根域名下的所有子域名和不同的端口**。

​	渲染进程准备好后，此时文档数据还在网络进程中，并没有提交给渲染进程，下一步就进入了提交文档阶段。

#### 	4.提交文档

提交文档就是：浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程。

- 当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；

- 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；

- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；

- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

  **确认提交后的动作：**

  ![image-20220328224714174](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203282247505.png)

#### 	5.渲染阶段

​	一旦文档被提交，渲染进程便开始页面解析和子资源加载，一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。



## 5、渲染流程(JS,CSS,HTML => 页面)

渲染流程包括：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成这几部分。

### （1）构建DOM

​	浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构即DOM 树。

构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM；



### （2）样式计算

#### 	1.把css转成styleSheets

​	浏览器无法直接理解纯文本的 CSS 样式，当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。这个结构具备查询和修改功能。

#### 	2.标准化样式表的属性值

​	将所有样式表值转换为渲染引擎容易理解的、标准化的计算值。

#### 	3.计算DOM树每个节点的具体样式

​	应用css的继承和层叠规则，给DOM树每个节点绑定样式属性。



### （3）布局阶段

​	计算DOM树中可见元素的几何位置，这个过程叫做**布局**。这个阶段要完成连两个任务：

#### 	1.创建布局树

​	额外地构建一棵只包含可见元素布局树；

#### 	2.布局计算



### （4）分层

​	为了实现一些复杂的效果，比如3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等。**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树**。图层叠加后合成了最终的页面。

![image-20220331205522755](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203312055013.png)

**通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。**

<font color="orange">新建图层的条件</font>：

第一点：拥有层叠上下文属性的元素会被提升为单独的一层；（如定位属性元素）

第二点：需要剪裁的地方也会被创建为图层。（滚动条或者超出显示的部分）



### （5）栅格化操作

绘制操作是由渲染引擎中的合成线程来完成的。

用户可以看到的部分叫做视口。合成线程将图层划分为图块，这些图块的大小通常是 256x256 或者 512x512。合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

![image-20220331210328577](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203312103832.png)

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。



### （6）合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，将该命令提交给浏览器进程，浏览器进程中的viz组件接受命令后，将页面内容绘制到内存中，显示在屏幕上。



### （7）渲染流程总结

![image-20220331210857452](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203312108664.png)

- 渲染进程把HTML内容转换成DOM树结构；
- 渲染引擎把CSS转换成styleSheet，计算DOM节点样式；
- 创建布局树，计算绑定布局样式信息；
- 对布局树分层，生成分层树；
- 对每个图层生成绘制列表，交给合成线程；
- 合成线程把图层分层成图块，在光栅化线程池将图块转化成位图；
- 合成线程发送绘图指令给浏览器进程；
- 浏览器进程根据指令生成页面，显示在显示器上。



### （8）重排、重绘、合成

#### 	1.更新元素的几何属性（重排）

更改元素宽高，会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。重排**需要更新完整的渲染流水线**，所以**开销也是最大的**。

#### 	2.更新元素的绘制属性（重绘）

更改元素背景颜色等，直接进入了绘制阶段，跳过布局阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘**省去了布局和分层阶段**，所以执行效率会比重排操作要高一些。

#### 	3.直接合成阶段

更改一个既不要布局也不要绘制的属性（使用CSS的transform实现动画效果），渲染引擎将**跳过布局和绘制**，只执行后续的合成操作，我们把这个过程叫做合成。会直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。



# 二、浏览器中的JS执行机制

## 1、变量提升

​	所谓的变量提升，是指在 JavaScript 代码执行过程中，**JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”**。变量被提升后，会给变量设置默认值，这个默认值就是 undefined。之所以要进行变量提升，是因为JS代码执行前需要进行**编译**。

### （1）JS代码的执行流程

**实际上变量和函数声明在代码里的位置是不会改变的，而且是在<font color=orange>编译阶段被 JavaScript 引擎放入内存中</font>**

一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。

![image-20220331214629936](https://raw.githubusercontent.com/Rainchen0504/picture/master/202203312146672.png)

#### 	1.编译阶段

输入一段代码会生成两部分：**执行上下文和可执行代码**。

```js
//变量提升部分
var myname = undefined
function showName() {
    console.log('函数showName被执行');
}
//执行部分
showName()
console.log(myname)
myname = '极客时间'
```

这段代码编译时，**执行上下文中包括<font color="orange">变量环境</font>（声明部分）和<font color="orange">词法环境</font>**。可执行代码包括调用和赋值部分

**执行上下文是 JavaScript 执行一段代码时的运行环境**，在执行上下文中存在一个变量环境的对象，该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。

#### 	2.执行阶段

JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行，并从变量环境中查找变量和函数。

当一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数。



## 2、调用栈

调用栈是用来管理函数调用关系的一种数据结构。要搞清楚首先弄明白函数调用和栈结构。

### （1）函数调用

​	就是运行函数，在执行 JavaScript 时，可能会存在多个执行上下文，使用栈的数据结构来管理。

### （2）栈

​	单行道，一端堵住，只能后进的车先出，先进的后出。这个单行道就可以看成栈容器，开进单行道叫做入栈，倒出叫做出栈。

### （3）JS调用栈

JS引擎使用栈结构管理上下文的，管理执行上下文的栈称为执行上下文栈，又称调用栈。

```js
//用一段代码来举例
var a = 2
function add(b,c){
  return b+c
}
function addAll(b,c){
  var d = 10
  result = add(b,c)
  return  a+result+d
}
addAll(3,6)
```

对上面代码逐步分析：

- 第一步：创建全局上下文，将其压入栈底。

![image-20220401151233486](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204011512629.png)

然后JS执行全局代码。先执行a = 2

![image-20220401151451212](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204011514286.png)

- 第二步：调用addAll函数

JS引擎会编译该函数，创建一个函数执行上下文，然后把函数的执行上下文压入栈中。

![image-20220401151701432](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204011517667.png)

addAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。

- 第三步：执行add函数调用

编译并创建执行上下文，并将其压入调用栈。

![image-20220401151831868](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204011518576.png)

当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9。

![image-20220401151922810](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204011519852.png)

紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。

![image-20220401151938824](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204011519840.png)

JS流程执行结束。**调用栈是 JavaScript 引擎追踪函数执行的一个机制**。

### （4）总结

- 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。
- 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
- 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
- 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。



## 3、块级作用域

### （1）作用域

​	作用域是程序中**<font color=orange>定义变量的区域</font>**，该位置**决定了变量的生命周期**。<font color=red>**作用域就是变量和函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。**</font>

​	在ES6出现之前，ES的作用域只有两种：全局作用域和函数作用域。

- 全局作用域

  全局作用域中的对象在代码任何地方都能访问，伴随着页面生命周期。

- 函数作用域

  函数内部定义的变量或函数，只能在函数内部访问，函数执行结束后会被销毁。

  #### 块级作用域

  块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。

### （2）变量提升带来的问题

1.变量容易在不被察觉时被覆盖；

2.本应该销毁的变量没有被销毁；

### （3）ES6解决变量提升的方法

​	ES6 **引入了 let 和 const 关键字**，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。

​	使用 let 关键字声明的变量是可以被改变的，而使用 const 声明的变量其值是不可以被改变的。



## 4、作用域链和闭包

### （1）作用域链

​	每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

```js
function bar() { console.log(myName) }
function foo() { var myName = "极客邦"; bar(); }
var myName = "极客时间"
foo()	//"极客时间"
```

<img src="https://raw.githubusercontent.com/Rainchen0504/picture/master/202204021620599.png" alt="image-20220402162052194" style="zoom:80%;" />

虚线链条就是**作用域链**。

#### 	1.词法作用域

​	词法作用域就是指作用域是由代码中函数声明的位置来决定的，词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

​	上面例子中foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数**使用了一个它们没有定义的变量，那么它们会到全局作用域去查找**。也就是说，**<font color=orange>词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系</font>**。

#### 	2.块级作用域中的变量查找

![image-20220402165411403](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204021654948.png)

​	bar在函数执行上下文找test没找到，根据词法作用域在全局执行上下文找到test为1。



### （2）闭包

看一段代码

```js
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

上面代码调用foo函数到return innerBar的调用栈：

![image-20220402172624109](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204021726492.png)

当foo函数执行完后，调用栈状态：

![image-20220402172813135](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204021728238.png)

这两个变量就叫做foo函数的闭包。

### 	在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量

​	**<font color=red>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量</font>，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。**

当执行到bar.setName方式时，调用栈：

![image-20220402173245422](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204021732093.png)

​	setName 的执行上下文中没有 myName 变量，foo 函数的闭包中包含了变量 myName，所以调用 setName 时，会修改 foo 闭包中的 myName 变量的值。同样的流程，当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo 函数闭包中的。

​	<font color=red>当有闭包时，JS引擎会沿着"**当前执行上下文 -->  函数闭包 --> 全局执行上下文**"顺序来查找变量</font>，这个顺序就是一个完整的作用域链。



#### 闭包的回收

​	如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

​	如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量，JS引擎执行垃圾回收机制时会判断是否在使用，然后回收此处内存。



## 5、this

作用域链和this是两套不同的系统

### （1）JS中的this

![image-20220405230115570](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204052301004.png)

this是和执行上下文绑定的，每个执行上下文都有一个this。



### （2）全局执行上下文的this

​	全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。



### （3）函数执行上下文的this

​	默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。为了**让this指向其它对象**，有以下三种方式：

#### 	1.通过函数的 call 方法设置

```js
let bar = {
  myName : "极客邦",
}
function foo(){
  this.myName = "极客时间"
}
foo.call(bar)
console.log(bar)	//{myName:"极客时间"}
```

还可以使用 bind 和 apply 方法来设置函数执行上下文中的 this。

#### 	2.通过对象调用方法设置

​	**使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的**。

```js
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
  }
}
myObj.showThis()
//等价于myObj.showThis.call(myObj)
```

- 在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。
- 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。

#### 	3.通过构造函数中设置

```js
function CreateObj(){
  this.name = "极客时间"
}
var myObj = new CreateObj()
```

当new CreateObj时，JS引擎做了四件事：

- 创建一个空对象；
- 调用CreateObj.call方法，把创建的空对象作为call的参数，相当于把CreateObj的this指向了新创建的空对象；
- 然后执行CreateObj函数，让函数执行上下文中的this指向新对象，给新对象增加属性；
- 然后返回新创建对象；

```js
//相当于
  var tempObj = {}	//创建新对象
  CreateObj.call(tempObj)	//改变指向
  return tempObj	//返回对象
```



### （4）this的缺陷和应对方案

#### 1.嵌套函数中的 this 不会从外层函数中继承

解决方法：

- 第一种是把 this 保存为一个变量，再利用变量的作用域机制传递给嵌套函数；
- 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。

#### 2.普通函数中的 this 默认指向全局对象 window

​	可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决问题了。



# 三、V8工作原理

## 1、栈空间和堆空间

JS内存机制：数据的存放

### （1）JS语言类型

​	在声明变量之前需要先定义变量类型的称为**<font color=red>静态语言</font>**；

​	在运行过程中需要检查数据类型的语言称为**<font color=red>动态语言</font>**；

**JS就属于动态语言**，在声明变量之前不需要确认其数据类型。

​	支持隐式类型转换的语言称为<font color=red>**弱类型语言**</font>；

​	不支持隐式类型转换的称为<font color=red>**强类型语言**</font>；

**JS属于弱类型语言**

![image-20220407134858299](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204071349021.png)



### （2）JS的数据类型

![img](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204071358941.png)

​	JS中的数据类型一共有8种，包含**Boolean，Number，String，Undefined，Null，Symbol，BigInt，Object。**

注意⚠️：

- 使用 **typeof 检测 Null 类型时，返回的是 Object**。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。
- Object类型比较特殊，由其他7个类型组成的key-value对的数据类型。
- 对象是**引用数据类型**，其他7个是**原始数据类型**。



### （3）内存空间

​	JS执行过程中，主要有三种类型的内存空间，分别是<font color=orange>**代码空间、栈空间和堆空间**</font>。

#### 	1.堆空间

​	**引用类型的值是存放在“堆”中的**。对象类型是存放在堆空间的，在栈空间中只是保留了对象的**引用地址**，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的。

#### 	2.栈空间

​	**原始类型的数据值都是直接保存在“栈”中的**。栈空间就是之前反复提及的调用栈，是用来存储执行上下文的。栈空间都不会设置太大，主要用来存放一些原始类型的小数据

#### 	3.堆空间存在的意义：

​	 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

**注意：⚠️**

​	在 JavaScript 中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。**



产生闭包的核心有两步：

- 第一步是需要预扫描内部函数；

- 第二步是把内部函数引用的外部变量保存到堆中。



## 2、垃圾回收

### （1）不同语言的垃圾回收策略

​	通常情况下，垃圾数据回收分为**手动回收**和**自动回收**两种策略。

1. C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的；
2. JavaScript、Java、Python使用的是自动垃圾回收的策略，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放；



### （2）栈中的数据回收

​	在调用栈中，有一个<font color=orange>**记录当前执行状态的指针**</font>（称为ESP），指向调用栈中正在执行函数的执行上下文。

​	当函数执行完成后，销毁该函数的执行上下文，JS会将ESP下移到将要执行函数的执行上下文，**这个下移操作就是销毁已完成执行函数执行上下文的过程**。

![image-20220409151101135](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091511523.png)

​	当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。



### （3）堆中的数据回收

**要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。**下面通过V8引擎来分析。

#### 	1.交际假说和分代收集（代际假说）

代际假说的两个特点：

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

这两个特点适用于大多数动态语言，包括Java、Python等。



​	在V8中会把堆分为**新生代**和**老生代**两个区域，新生代中存放的是<font color=orange>生存**时间短**的对象</font>，老生代中存放的<font color=orange>生存**时间久**的对象</font>。

​	新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用**两个不同的垃圾回收器**，以便更高效地实施垃圾回收。

- <font color=red>**副垃圾回收器**，主要负责新生代的垃圾回收</font>。

- <font color=red>**主垃圾回收器**，主要负责老生代的垃圾回收</font>。



#### 	2.垃圾回收工作流程

不论什么类型的垃圾回收器，它们都有一套共同的执行流程。

- ##### 第一步：

  ​	标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

- ##### 第二步：

  ​	回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

- ##### 第三步：

  ​	内存整理。频繁回收对象后，内存中就会存在大量不连续空间也称做内存碎片。如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。但这步其实是可选的，不是所有垃圾回收器都会产生内存碎片。



#### 	3.副垃圾回收器

​	副垃圾回收器主要负责新生区的垃圾回收，且回收频繁。

​	**<u>新生代中用 Scavenge 算法来处理</u>**。就是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

![image-20220409153356808](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091533027.png)

​	在垃圾回收过程中，首先要对对象区域中的垃圾做标记；清理阶段副垃圾回收器会把存活的对象复制到空闲区域中，并有序地排列起来相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

​	完成复制后，对象区域与空闲区域进行角色翻转，这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

​	由于新生代中采用的 Scavenge 算法每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，**所以为了执行效率，一般新生区的空间会被设置得比较小**。当<u>经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</u>



#### 	4.主垃圾回收器

​	主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，**一个是对象占用空间大，另一个是对象存活时间长。**

​	主垃圾回收器是采用**<font color=red>标记 - 清除</font>**的算法进行垃圾回收的。

- 标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

- 接下来就是垃圾的清除过程，这个过程有两种算法。

  - 一种是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。
  - 另一种是标记 - 整理算法，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

  

### （4）全停顿

​	由于JS时运行在主线程之上的，一旦执行垃圾回收算法，都需要停下正在执行的JS脚本，待垃圾回收完毕后再恢复脚本执行，这种行为叫做**全停顿**。

![image-20220409165325088](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091653745.png)

​	为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，这个算法称为**增量标记算法**。

![image-20220409165505584](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091655937.png)



## 3、编译器和解释器

### （1）编译器和解释器

​	存在的意义时机器不能直接理解代码，需要将代码翻译成机器码。按照语言执行流程，把语言分为<u>**编译型语言和解释型语言**</u>。

​	**编译型语言在程序执行之前，<font color=red>需要经过编译器的编译过程</font>**，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。

​	而由**解释型语言编写的程序，在每次运行时<font color=red>需要通过解释器对程序进行动态解释和执行</font>**。比如 Python、JavaScript 等都属于解释型语言。

![image-20220409170157128](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091701304.png)

#### 	1.编译型语言

​	在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。

#### 	2.解释型语言

在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。



### （2）V8执行JS代码过程

![image-20220409170543354](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091705638.png)

V8执行过程中**既有解释器又有编译器**。具体流程分析如下：

#### 	1.生成抽象语法树（AST）和执行上下文

执行上下文在浏览器中的JS执行机制已做说明，这里主要总结抽象语法树。

用一段代码展示下AST

```js
var myName = "极客时间"
function foo(){
  return 23;
}
myName = "geektime"
foo()
```

![image-20220409171348666](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091713834.png)

从图中可以看出，AST 的结构和代码的结构非常相似，可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。

##### AST是一种重要的数据结构，有着广泛的应用：

1. Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码。其工作原理是先将ES6源码转成AST，然后把ES6的AST转成ES5的AST，最后生成JS代码。
2. ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。

##### 生成AST经过两个阶段：

- <font color=orange>**第一阶段是分词，又称为词法分析**</font>。作用是将代码一行行拆成一个个token。token是指语法上不能再分的、最小的单个字符或者字符串。

![image-20220409172427714](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091724855.png)

- <font color=orange>**第二阶段是解析，又称为语法分析**</font>。作用是将token数据根据规则转成AST。

#### 	2.生成字节码

​	**解释器Ignition**会根据 AST 生成字节码，并解释执行字节码。

​	<u>**字节码是介于AST和机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。**</u>

![image-20220409172854001](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091728368.png)

字节码占用空间远远小于机器码，所以能减少系统的内存使用。

#### 	3.执行代码

​	如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。

​	在 Ignition 执行字节码的过程中，如果发现有**热点代码**（一段代码被重复执行多次），那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

![image-20220409173306725](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091733730.png)



### （3）JS性能优化

优化JS执行效率，应聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三个内容：

1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。



# 四、浏览器中的页面循环系统

## 1、消息队列和事件循环

- 使用单线程处理安排好的任务：

![image-20220409183203380](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091832663.png)

- 在线程运行过程中处理新任务：

![image-20220409183235413](/Users/rain_chen/Library/Application Support/typora-user-images/image-20220409183235413.png)

要想在线程运行过程中，能接收并执行新的任务，就需要采用**事件循环机制**。

- 处理其他线程发送过来的任务

![image-20220409183553368](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091835010.png)

​	**消息队列是一种数据结构**，**可以存放要执行的任务**。它符合队列“**先进先出**”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

![image-20220409183633732](/Users/rain_chen/Library/Application Support/typora-user-images/image-20220409183633732.png)

<u>队列和事件循环</u>

![image-20220409183707210](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091837192.png)

- 处理其他进程发送过来的任务

![image-20220409183803616](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204091838815.png)

​	**渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息**，接收到消息之后，会将这些消息组装成任务发送给渲染主线程。



### 消息队列中的任务类型

​	包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等。

​	除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。



### 安全退出

​	确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。如果设置了，那么就直接中断当前的所有任务，退出线程。



### 页面使用单线程的缺点

​	页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。

#### 1.处理高优先级的任务方法

​	通常我们把消息队列中的任务称为**宏任务**，每个宏任务中都包含了一个**微任务队列**，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

​	等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

#### 2.单个任务执行时常过久问题

​	JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。



### 总结

1. 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。
2. 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。
3. 如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。
4. 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。
5. 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。



## 2、WebAPI：setTimeout

​	**<font color=red>浏览器页面是由消息队列和事件循环系统来驱动的。</font>**

### （1）浏览器实现setTimeout

​	渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。

​	在 Chrome 中除了正常使用的消息队列之外，还有另外一个延迟消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。

### （2）使用 setTimeout 的注意事项

1. 如果当前任务执行时间过久，会影响定时器任务的执行：

2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒；

3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒；

4. 延时执行时间有最大值（Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒）；

5. 使用 setTimeout 设置的回调函数中的 this 指向全局环境。除非使用匿名函数或者bind方法。

   

## 3、WebAPI：XMLHttpRequest

### （1）回调函数和系统调用栈

​	将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是**<font color=red>回调函数</font>**。

- 如果回调函数是在主函数返回之前执行的，称为**同步回调**。

- 而回调函数在主函数外部执行的过程，称为**异步回调**。

  消息队列和主线程循环机制保证了页面有条不紊地运行。当循环系统在执行一个任务的时候，都要为这个任务维护一个**系统调用栈**。

​	每个任务在执行过程中都有自己的调用栈。同步回调就是在当前主函数的上下文中执行回调函数。异步回调是指回调函数在主函数之外执行，一般有两种方式：

- 第一种是把异步函数做成一个任务，添加到信息队列尾部；
- 第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。



### （2）XMLHttpRequest 运作机制

![image-20220411213641701](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204112136686.png)

```js
//原生ajax请求写法
 function GetWebData(URL){
    /**
     * 1:新建XMLHttpRequest请求对象
     */
    let xhr = new XMLHttpRequest()

    /**
     * 2:打开请求
     */
    xhr.open('Get', URL, true);//创建一个Get请求,采用异步


    /**
     * 3:配置参数
     */
    xhr.timeout = 3000 //设置xhr请求的超时时间
    xhr.responseType = "text" //设置响应返回的数据格式
    xhr.setRequestHeader("X_TEST","time.geekbang")

   /**
     * 4:注册相关事件回调处理函数 
     */
    xhr.onreadystatechange = function () {
        switch(xhr.readyState){
          case 0: //请求未初始化
            console.log("请求未初始化")
            break;
          case 1://OPENED
            console.log("OPENED")
            break;
          case 2://HEADERS_RECEIVED
            console.log("HEADERS_RECEIVED")
            break;
          case 3://LOADING  
            console.log("LOADING")
            break;
          case 4://DONE
            if(this.status == 200||this.status == 304){
                console.log(this.responseText);
                }
            console.log("DONE")
            break;
        }
    }

    xhr.ontimeout = function(e) { console.log('ontimeout') }
    xhr.onerror = function(e) { console.log('onerror') }
   
    /**
     * 5:发送请求
     */
    xhr.send();
}
```

#### 	第一步：创建 XMLHttpRequest 对象

JavaScript创建一个 XMLHttpRequest 对象 xhr，用来执行实际的网络请求操作。



####     第二步：配置基础的请求信息

​	通过 open 接口配置一些基础的请求信息，包括请求的地址、请求方法（是 get 还是 post）和请求方式（同步还是异步请求）。



#### 	第三步：为 xhr 对象注册回调函数

因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。

回调函数主要有下面几种：

1. ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；
2. onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；
3. onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。



#### 	第四步：发起请求

​	渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；

​	渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。

1. 如果网络请求出错了，就会执行 xhr.onerror；
2. 如果超时了，就会执行 xhr.ontimeout；
3. 如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。



## 4、宏任务和微任务

### （1）宏任务

页面大部分任务是在主线程上执行的：

- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件；

​    为了协调主线程上任务的执行，页面进程引入了**消息队列**和**事件循环机制**，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为**<font color=red>宏任务</font>**。

​	**宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。**



### （2）微任务

**微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。**

​	每个宏任务都关联了一个微任务队列，在现代浏览器里面，微任务有两种产生方式：

1. 第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。
2. 第二种方式是**使用 Promise**，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。

- 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
- 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。
- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。



### （3）监听DOM方法的演变

- 早期页面并没有提供对监听的支持，要观察 DOM 是否变化只能使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。
- 2000年引入Mutation Event采用了**观察者的设计模式**，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于**同步回调**。但是大量消耗浏览器性能，造成卡顿，被从web标准事件中删除。
- DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。具体就是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。
- 在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。
- MutationObserver 采用了“异步 + 微任务”的策略。通过异步解决性能问题，通过微任务解决实效性问题。



## 5、Promise

封装异步代码，让处理流程变得线性。

![image-20220411221321711](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204112213830.png)

回调地狱的产生原因：

1. 多层嵌套的问题；
2. 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。

​    Promise 通过**回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”技术**解决了上面的两个问题。

​	**Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的。**



## 6、async/await

​	fetch方法被定义在window对象中，可以用它来发起对远程资源的请求，该方法返回的是一个 Promise 对象。

​	**ES7 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下<font color=red>使用同步代码实现异步访问资源的能力</font>，并且使得代码逻辑更加清晰**

### （1）生成器和协程

​	生成器函数是一个带星号的函数，而且是**可以暂停执行和恢复执行**的。

具体使用方法：

1. 在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。
2. 外部函数可以通过 next 方法恢复函数的执行。



函数可以暂停和恢复的原因：

​	**协程是一种比线程更加轻量级的存在**。可以把协程看成是跑在线程上的任务，一个线程可以存在多个协程，但是在线程上同时只能执行一个协程。

​	协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）

![image-20220418005334249](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204180053519.png)

1. 通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。
2. 要让 gen 协程执行，需要通过调用 gen.next。
3. 当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。
4. 如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。

**通常把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器。**



### （2）async/await

​	async 是一个通过**异步执行**并**隐式返回 Promise** 作为结果的函数。

​	async/await的出现能够彻底告别执行器和生成器，但是async/await 技术背后的秘密就是 **Promise 和生成器**应用，往底层说就是微任务和协程应用。

#### 1.async

async 是一个通过<font color=orange>**异步执行**</font>并<font color=orange>**隐式返回 Promise** </font>作为结果的函数。

```js
//举个例子
async function foo(){
  return 2
}
console.log(foo());	//Promise {: 2}
//调用 async 声明的 foo 函数返回了一个 Promise 对象，状态是 resolved
```

#### 2.await

```js
//代码举例
async function foo() {
    console.log(1)
    let a = await 100
    console.log(a)
    console.log(2)
}
console.log(0)
foo()
console.log(3)
// 0 1 3 100 2
//首先执行0语句
//接着调用foo函数，打印1
//然后执行await语句，默认创建一个Promise对象，resolve(100)，这个100就交给了微任务队列；
//然后JS引擎暂停当前协程，把主线程的控制权交给父协程；
//父协程执行log(3)，父协程执行结束，进入微任务队列执行，触发promise.then，也就是执行resolve(100)；
//主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程；
//foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。
```

![image-20220418010517029](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204180105138.png)

总结：async函数内部await之前的直接执行，await关键字后面执行的代码，看作是包裹在`(resolve,reject) => {函数执行}`中的代码 ，属于直接执行的代码；await的下一条看作是then(res => {函数执行})中的代码，进入微任务队列；



# 五、浏览器中的页面

## 1、Chrome开发者工具

​	Chrome 开发者工具（简称 DevTools）是一组网页制作和调试的工具，内嵌于 Google Chrome 浏览器中。这里针对**页面的源头**和**网络数据的接收**来分析。

开发者工具包含的10个功能面板：

![img](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204181553738.png)

### （1）网路面板

组成部分：控制器、过滤器、抓图信息、时间线、详细列表和下载信息6部分构成。

![image-20220418155509893](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204181555646.png)

#### 	1.控制器

控制器有4个比较重要的功能

![image-20220418161527198](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204181615010.png)

- 红色圆点的按钮，表示“开始 / 暂停抓包”。

- “全局搜索”按钮，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个你想要的文件上。

- Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。

- Online 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网。

#### 2.过滤器

主要就是起过滤功能。因为有时候一个页面有太多内容在详细列表区域中展示了，而你可能只想查看 JavaScript 文件或者 CSS 文件，这时候就可以通过过滤器模块来筛选你想要的文件类型。

#### 	3.抓图信息

抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。

#### 	4.时间线

主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。如果是多条竖线堆叠在一起，那说明这些资源被同时被加载。至于具体到每个文件的加载信息，还需要用到下面要讲的详细列表。

#### 	5.详细列表

详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息。

#### 	6.下载信息概要

- DOMContentLoaded，说明页面已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了。
- Load，说明浏览器已经加载了所有的资源（图像、样式表等）。



### （2）详细列表

#### 1.详细信息

![image-20220418162609914](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204181626346.png)

#### 2.单个资源的时间线

![img](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204181821473.png)

发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍

**<font color=red>时间线面板：</font>**

![image-20220418162641205](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204181626195.png)

- 首先是 Queuing也就是排队
  - 页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，**所以优先级最高**；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。
  - 浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。
  - 最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。
- 排队结束后，发起连接，但是可能会导致过程推迟，表现在面板中的 Stalled 上，表示推迟。
- 如果使用了代理服务器，还会增加一个 Proxy Negotiation 阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间。
- 和服务器建立连接的阶段Initial connection/SSL，包括了建立 TCP 连接所花费的时间；不过如果使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。
- 和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是 Request sent 阶段。
- 数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“**第一字节时间**”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。
- 接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是 Content Download 阶段，这意味着从第一字节时间到接收到全部响应数据所用的时间。



### （3）优化时间线上耗时项

#### 1.排队时间过久

​	排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为**域名分片技术**。除了域名分片技术外，我个人还建议你**把站点升级到 HTTP2**，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。

#### 2.第一字节时间过久

可能原因：

1. **服务器生成页面数据的时间过久**。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。
2. **网络的原因**。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。
3. **发送请求头时带上了多余的用户信息**。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。

解决方案：**增加各种缓存的技术；使用 CDN 来缓存一些静态文件；发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息。**

#### 3.Content Download 时间过久

减少文件大小，比如压缩、去掉源码中不必要的注释等方法。



## 2、DOM树

​	从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM，**DOM提供了对HTML文档结构化的表述**。

- 从页面世视角来看，DOM是生成页面的基础数据结构；
- 从JS脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口；
- 从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。

<font color=orange>DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</font>

### （1）DOM树的生成

​	渲染引擎内部有**HTML解析器模块**，**负责将HTML字节流转换成DOM结构**。

​	网络进程加载了多少数据，HTML 解析器便解析多少数据。

​	网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。

​	渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器，解析器会动态接收字节流，并将其解析为 DOM。

![image-20220418204326747](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204182043247.png)

### （2）JS影响DOM

​	当解析到`<script>`标签时，渲染引擎判断这是一段脚本， HTML 解析器就会暂停 DOM 的解析，执行JS并可能修改当前已经生成的 DOM 结构。

​	 JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。浏览器主要的优化点是**预解析操作**。

​	当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

​	JavaScript 线程会阻塞 DOM，可以使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。



## 3、CSS渲染

![image-20220418203533692](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204182035951.png)

#### 渲染流水线

​	主页面发起请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。

​	当渲染进程接收 HTML 文件字节流时，会先开启一个**预解析线程**，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。但是，在 DOM 构建结束之后、css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。

### （1）CSSOM的作用

​	渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，**第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。**这个 CSSOM 体现在 DOM 中就是document.styleSheets。



### （2）影响页面展示的因素以及优化策略

​	渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验。

​	首次白屏时间的瓶颈主要体现在**下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript**。

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。



## 4、分层和合成机制

### （1）显示器显示图像过程：

​	显示器有固定的刷新频率，通常为60HZ即每秒更新60张图片。显示器每秒固定从显卡中的**<font color=orange>前缓冲区</font>**读取60次图像，并将读取的图像显示到显示器上。



### （2）显卡作用：

​	显卡负责合成新的图像，并将图像保存到**<font color=orange>后缓冲区</font>**中，一旦图像写到后缓冲区系统就会置换前后缓冲区，保证显示器能读取到最新显卡合成的图像。



### （3）帧和帧率

​	**渲染流水线生成的每一幅图片称为一帧，每秒更新了多少帧称为帧率。**Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制，**分层和合成机制代表了当今最先进的渲染技术**。



### （4）生成一帧图像

生成一帧有**重排**、**重绘**和**合成**三种方式。

这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。

#### 重排：

需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。

#### 重绘：

没有重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。

#### 合成：

并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。



### （5）Chrome合成技术

可以用三个词来概括总结：**<font color=red>分层、分块和合成</font>**。

#### 	1.分层和合成

​	将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。

​	在 Chrome 的渲染流水线中，**分层体现在生成布局树之后**，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。绘制流程生成绘制指令列表，进入光栅化阶段，栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。

​	**合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。**这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

#### 	2.分块

​	分层在宏观上提升了渲染效率，分块则是在微观层面上提升了渲染效率。

​	合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。

​	**在首次合成图块的时候使用一个低分辨率的图片**。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。



### （6）利用分层技术优化代码

```css
.box {
	will-change: transform, opacity;
}
```

​	使用will-change告诉渲染引擎会对该元素做一些特效变换，渲染引擎会将该元素单独实现一层，等变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。

​	但是，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以需要恰当地使用 will-change。



## 5、页面性能

页面优化，就是让页面更快地显示和响应。通常一个页面的生命周期有三个阶段：**加载阶段、交互阶段和关闭阶段**。

- 加载阶段，从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和JS脚本。
- 交互阶段，从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是JS脚本。
- 关闭阶段，用户发出关闭指令后页面所做的一些清理操作。

下面重点关注加载和交互阶段。

### （1）加载阶段

一个加载阶段渲染流水线图例：

![image-20220419175158719](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204191751972.png)

​	并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染。而JS首次请求的HTML资源文件、CSS文件都是会阻塞首次渲染的。**能阻塞网页首次渲染的的资源称为关键资源**。细化三个影响页面首次渲染的核心因素：

1. **第一个是关键资源个数**。关键资源个数越多，首次页面的加载时间就会越长。
2. **第二个是关键资源的大小**。所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。
3. **第三个是请求关键资源需要多少RTT**。RTT 就是往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延.

因此，总的优化原则就是**减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数**。

- 如何减少关键资源的个数？
  - 一种方式是可以将 JavaScript 和 CSS 改成内联的形式；
  - 如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；
  - 如果CSS不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志；
- 如何减少关键资源的大小？
  - 可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容；
  - 取消 CSS 或者 JavaScript 中关键资源的方式；
- 如何减少关键资源 RTT 的次数？
  - 减少关键资源的个数和减少关键资源的大小搭配来实现；
  - 使用 CDN 来减少每次 RTT 时长；



### （2）交互阶段

​	交互阶段的优化，其实就是**渲染进程渲染帧的速度**，在交互阶段，帧的渲染速度决定了交互的流畅度。

![image-20220419180626817](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204191806942.png)

#### 	1.减少JS脚本执行时间

- 将一次执行的函数分解为多个任务，使得每次的执行时间不要过久；
- 采用 Web Workers，可以当作主线程之外的一个线程，不过 Web Workers 中没有 DOM、CSSOM 环境，无法通过 JavaScript 来访问 DOM ；

#### 	2.避免强制同步布局

​	在修改 DOM 之前查询相关值

#### 	3.避免局部抖动

​	指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。尽量不要在修改 DOM 结构时再去查询一些相关值。

#### 	4.合理利用CSS合成动画

​	合成动画是直接在合成线程上执行的，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。如果能让 CSS 处理动画，就尽量交给 CSS 来操作。

​	如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，告诉渲染引擎需要将该元素单独生成一个图层。

#### 	5.避免频繁的垃圾回收

​	尽可能优化储存结构，尽可能避免小颗粒对象的产生。



## 6、虚拟DOM

### （1）虚拟DOM的任务

将页面改变的内容应用到虚拟DOM上，而不是直接应用到DOM上；

变化被应用到虚拟DOM上时，虚拟DOM并不着急渲染页面，仅仅调整虚拟DOM的内部状态；

虚拟DOM收集到足够的变化时，再把这些变化一次性应用到真实的DOM上。

![image-20220420104549106](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204201045314.png)

### （2）虚拟DOM的运行过程（参考react）

- 创建阶段
  - 首先根据模板和基础数据创建出来虚拟DOM，然后由虚拟DOM创建出真实DOM树结构，真实DOM生成后，再触发渲染流水线往屏幕上输出。
- 更新阶段
  - 数据发生了改变时，生成一个新的虚拟DOM和之前的虚拟DOM进行比较，这个过程会找出变化节点，然后把变化的节点应用到DOM树上，最后渲染引擎更新渲染流水线，生成新的页面。



### （3）双缓存

​	屏幕从前缓冲区读取数据然后显示，但是很多复杂可能需要计算多次才能完成。如果每次计算完一部分图像，就写入缓冲区，那么在显示一个稍微复杂点的图像的过程中，页面效果可能是一部分一部分地显示出来，会让用户感受到界面的闪烁。

​	使用双缓存可以先将计算的中间结果存放到另一个缓冲区中，等全部的计算结束，缓冲区存储了完整的图形，再一次性复制到显示缓冲区，使得图像输出更加稳定。



### （4）MVC模式

![image-20220420111112515](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204201111741.png)

**核心思想是数据与视图分离**，衍生出MVP和MVVM等。

![image-20220420163010814](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204201630552.png)

<center>基于React和Redux构建的MVC模型</center>

1. 控制器是用来监控DOM的变化，一旦DOM变化，控制器就会通知模型，更新数据；
2. 模型数据更新好后，控制器会通知视图，告诉视图模型的数据发生了变化；
3. 视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；
4. 新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；
5. 比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；
6. DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。



## 7、渐进式网页应用(PWA)

### （1）浏览器的三大进化路线

1. 第一个是应用程序Web化；
2. 第二个是Web应用移动化；
3. 第三个是Web操作系统化；



### （2）PWA

PWA就是渐进式网页应用，“渐进式 + Web应用”。

- Web就是普通的Web页面，；
- 渐进式要从下面两个方面理解：
  - 站在 Web 应用开发者来说，PWA 提供了一个渐进式的过渡方案，让 Web 应用能逐步具有本地应用的能力。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位；
  - 站在技术角度来说，PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。

PWA 采取的是非常一个**缓和的渐进式策略**，不再像以前那样激进，动不动就是取代本地 App、取代小程序。与之相反，而是要充分发挥 Web 的优势，**渐进式地缩短和本地应用或者小程序的距离**。

个人理解为：**<font color=orange>它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。基于这套理念之下的技术都可以归类到 PWA。</font>**



### （3）web应用VS本地应用

- Web应用缺少离线使用能力，在离线或者弱网环境下基本是无法使用的。
- Web应用缺少消息推送能力，作为一个 App 厂商，需要有将消息送达到应用的能力。
- Web缺少一级入口，也就是把Web应用安装到桌面，通过桌面打开。

PWA 提出了两种解决方案：**通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题**



### （4）Service Worker

**在页面和网络之间增加一个拦截器，用来缓存和拦截请求。**

![image-20220420174233622](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204201742860.png)

​	在没有安装 Service Worker 之前，WebApp 都是直接通过网络模块来请求资源的。安装了 Service Worker 模块之后，WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源。一切的控制权都交由 Service Worker 来处理。

#### 	1.架构

​	Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外，不过由于 Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。

​	**“让其运行在主线程之外”就是 Service Worker 来自 Web Worker 的一个核心思想**。不过 Web Worker 是临时的，每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。

由于 Service Worker 还需要会为多个页面提供服务，所以还**不能把 Service Worker 和单个页面绑定起来**。在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。

#### 	2.消息推送

​	消息推送也是基于 Service Worker 来实现的。因为消息推送时，浏览器页面也许并没有启动，这时就需要 Service Worker 来接收服务器推送的消息，并将消息通过一定方式展示给用户

#### 	3.安全

​	要使用Service Worker 站点需要升级到HTTPS。因为采用 HTTPS 的通信数据都是经过加密的，即便拦截了数据，也无法破解数据内容，而且 HTTPS 还有校验机制，通信双方很容易知道数据是否被篡改。



## 8、WebComponent

组件化；**<font color=red>对内高内聚，对外低耦合</font>**。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。

### （1）webComponent组件化开发

**WebComponent 是一套技术的组合，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和HTML templates（HTML 模板）**

使用时，需要实现下面三个步骤：

- **首先，使用template属性创建模版**。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，DOM 树中的 template 节点不会出现在布局树中。所以 template 可以自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。

- **其次，需要创建一个类**。在这个类的构造函数中需要完成三件事：

  -  查找模板内容；
  - 创建影子DOM；
  - 再将模板添加到影子DOM上；

  ​    影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了，创建好后，使用customElements.define 来自定义元素。

- **像正常使用HTML元素一样使用该元素**。

```html

<!DOCTYPE html>
<html>
<body>
    <!--
            一：定义模板
            二：定义内部CSS样式
            三：定义JavaScript行为
    -->
    <template id="geekbang-t">
        <style>
            p {
                background-color: brown;
                color: cornsilk
            }
            div {
                width: 200px;
                background-color: bisque;
                border: 3px solid chocolate;
                border-radius: 10px;
            }
        </style>
        <div>
            <p>time.geekbang.org</p>
            <p>time1.geekbang.org</p>
        </div>
        <script>
            function foo() {
                console.log('inner log')
            }
        </script>
    </template>
    <script>
        class GeekBang extends HTMLElement {
            constructor() {
                super()
                //获取组件模板
                const content = document.querySelector('#geekbang-t').content
                //创建影子DOM节点
                const shadowDOM = this.attachShadow({ mode: 'open' })
                //将模板添加到影子DOM上
                shadowDOM.appendChild(content.cloneNode(true))
            }
        }
        customElements.define('geek-bang', GeekBang)
    </script>


    <geek-bang></geek-bang>
    <div>
        <p>time.geekbang.org</p>
        <p>time1.geekbang.org</p>
    </div>
    <geek-bang></geek-bang>
</body>
</html>
```

渲染结果：

![image-20220421195624659](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204211956871.png)

### （2）浏览器实现影子DOM

影子DOM的作用有以下两点：

1. 影子DOM中的元素对于整个网页是不可见的；
2. 影子DOM的CSS不会影响到整个网页的CSSOM，影子DOM内部的CSS只对内部的元素起作用；

![image-20220421200032959](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204212002215.png)



# 六、浏览器中的网络

## 1、HTTP - 1.HTTP性能优化

HTTP是浏览器中**最重要**也是**使用最多**的协议，是**浏览器和服务器之间的通信语言**。

### （1）超文本传输协议HTTP/0.9

1991年提出，主要用于学术交流，用来在网络之间传递HTML超文本内容，所以称为超文本传输协议。

![image-20220421201251894](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204212012425.png)

-  HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。
- 建立好连接之后，会发送一个 GET 请求行的信息，如GET /index.html用来获取 index.html。
- 服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。
- HTML 文档传输完成后，断开连接。

HTTP/0.9的特点：

1. 只有一个请求行，没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。
2. 服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。
3. 返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。



### （2）被浏览器推动的HTTP/1.0

​	万维网的发展提出了新的协议要求，<font color=orange>**支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求**</font>，文件格式不局限于ASCII 编码，还有很多其他类型编码的文件。

![image-20220421201800186](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204212018393.png)

增加了响应头和响应体来支持不同类型的数据。在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码

```js
accept: text/html//期望服务器返回 html 类型的文件
accept-encoding: gzip, deflate, br//期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式
accept-Charset: ISO-8859-1,utf-8//期望返回的文件编码是 UTF-8 或者 ISO-8859-1
accept-language: zh-CN,zh//期望页面的优先语言是中文
```

服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据，最终浏览器需要根据响应头的信息来处理数据。

其他新增的典型特性：

1. 引入了**状态码**。状态码是通过响应行的方式来通知浏览器的；
2. 提供了 **Cache 机制**，用来缓存已经下载过的数据；
3. 服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了**用户代理**的字段。



### （3）HTTP/1.1

#### 	1.改进持久连接

HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段。

**HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。**有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。**浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。**

#### 	2.不成熟的HTTP管线化

将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。谷歌放弃了管线化技术。

#### 	3.提供虚拟主机的支持

HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。

#### 	4.对动态生成的内容提供了完美支持

HTTP/1.1 通过引入 **Chunk transfer 机制**解决浏览器不知道何时会接收完所有的文件数据问题。服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。

#### 	5.客户端Cookie、安全机制



## 2、HTTP - 2.提升网络速度

### （1）HTTP/1.1的主要问题

​	**<font color=red>带宽是每秒最大能发送或接收的字节数</font>**。把每秒能发送的最大字节数称为**上行带宽**，每秒能够接收的最大字节数称为**下行带宽**。HTTP/1.1 很难将带宽用满。

主要原因有三个：

- TCP 的慢启动

一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。

- 开启了多条 TCP 连接，连接会竞争固定的带宽

有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。

- HTTP/1.1 队头阻塞的问题

HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着不能随意在一个管道中发送请求和接收内容。



### （2）HTTP/2的多路复用

**<font color=red>一个域名只使用一个 TCP 长连接和消除队头阻塞问题</font>。**

![image-20220424135216883](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204241352159.png)

每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。

​	HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。

#### 多路复用的实现：

![image-20220424140853567](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204241408873.png)

HTTP/2 添加了一个**二进制分帧层**。

1. 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
2. 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
3. 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
4. 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
5. 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
6. 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。

**通过引入二进制分帧层，就实现了 HTTP 的多路复用技术**。



### （3）HTTP/2其他特性

#### 	1.可以设置请求的优先级

HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。

#### 	2.服务器推送

HTTP/2 还可以直接将数据提前推送到浏览器。当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。

#### 	3.头部压缩

HTTP/2 对请求头和响应头进行了压缩，提升了大量请求时的传输效率。



## 3、HTTP - 3.构建高效网络

### （1）TCP队头堵塞

​	HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。

![image-20220424142836008](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204241428156.png)

当出现丢包时：

![image-20220424142902158](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204241429204.png)

**在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞**。

![image-20220424143020417](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204241430666.png)

​	在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。

​	这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。



### （2）TCP建立连接的延时

TCP 的握手过程也是影响传输效率的一个重要因素。

**网络延迟**又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。

![image-20220424143316179](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204241433161.png)

​	HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。

1. 在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。
2. 进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT。

在传输数据之前，需要花掉 **3～4 个 RTT**。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30～40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300～400 毫秒，这时用户就能明显地感受到“慢”了。



### （3）TCP协议僵化

TCP协议具有队头堵塞和建立连接慢的问题，但是想改进TCP时非常困难的。

- **中间设备的僵化是一个原因**。

  路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。

- **操作系统也是导致 TCP 协议僵化的另外一个原因**

  TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。



### （4）QUIC协议

HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，这套功能称为 **QUIC 协议**。

![image-20220424150221447](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204241502938.png)

QUIC协议集成了以下几点功能：

- **实现了类似 TCP 的流量控制、传输可靠性的功能**。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。
- **集成了 TLS 加密功能**。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。
- **实现了 HTTP/2 中的多路复用功能**。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。



![image-20220424150354332](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204241503358.png)

- **实现了快速握手能力**。QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。



#### （5）HTTP/3实现的前提

1. 服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持；
2. 部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度；
3. 中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。



# 七、浏览器安全

## 1、同源策略（为什么不能跨域）

### **浏览器安全分为三大板块**

**<font color=orange>Web页面安全、浏览器网络安全和浏览器系统安全</font>**。页面中**最基础、最核心的安全策略**：同源策略。



### （1）同源策略

​	如果两个 URL 的**协议、域名和端口都相同**，我们就称这两个 URL 同源。浏览器默认**两个相同的源之间是可以相互访问资源和操作 DOM 的**。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。

同源策略具体表现在DOM、Web数据和网络三个层面：

- 第一个，**DOM层面**。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。
- 第二个，**数据层面**。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。
- 第三个，**网络层面**。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。默认情况下不能访问跨域的资源。



### （2）安全和便利性的权衡

浏览器让步的安全性问题：

#### 1.页面中可以嵌入第三方资源

浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。

还能将页面的的敏感数据，如 Cookie、IndexDB、LoacalStorage 等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器。

为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。**CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。**通过这些手段就可以大大减少 XSS 攻击。

#### 2.跨域资源共享

默认情况下在一个页面向另一个不同源网址请求资源，同源策略会阻止请求。为解决此问题，引入**跨域资源共享（CORS）**，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。

#### 3.跨文档消息机制

如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了**跨文档消息机制**，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。



## 2、跨站脚本攻击（XSS）

### （1）XSS攻击

​	跨站脚本攻击，指**黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。**

恶意脚本能做的事：

- 可以窃取 Cookie 信息。可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
- 可以监听用户行为。可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。
- 可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
- 还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。



### （2）恶意脚本注入

常见的注入方式：**<font color=orange>存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击</font>**三种方式。

#### 1.存储型XSS攻击

![image-20220426175302630](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204271133865.png)

常见的就是在input输入框输入`<script>恶意代码或者获取信息的代码</script>`保存到数据库，然后当用户打开时就会执行。

#### 2.反射型XSS攻击

​	用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。

​	**Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。**

#### 3.基于DOM的XSS攻击

​	基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器。黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，比如通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的。共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。



### （3）如何阻止XSS攻击

#### 1.服务器对输入脚本进行过滤或转码

不管是反射型还是存储型 XSS 攻击，都可以**在服务器端将一些关键的字符进行转码**。

```js
code:<script>alert('你被xss攻击了')</script> //过滤后剩code:

code:&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt; //转码结果
```

#### 2.充分利用CSP

实施严格的CSP可以有效防范XSS攻击：

1. 限制加载其他域下的资源文件；
2. 进行向第三方域提交数据，保证数据不会泄漏；
3. 禁止执行内联脚本和未授权的脚本；
4. 提供上报机制，帮助尽快发现XSS攻击；

#### 3.使用HttpOnly属性

​	使用HttpOnly可以**保护Cookie安全**。通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。

#### 4.添加验证码



## 3、CSRF攻击

​	跨站请求伪造，黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单讲，**CSRF攻击就是黑客利用用户的登录状态，并通过第三方的站点做一些坏事**。

### （1）CSRF实施方式

#### 1.自动发起Get请求

最容易实施的攻击方式是自动发起 Get 请求,比如黑客把请求接口隐藏在img标签中，欺骗浏览器是一张图片资源，当页面被加载时就会自动发起请求，实现破坏。

```js
<!DOCTYPE html>
<html>
  <body>
    <h1>黑客的站点：CSRF攻击演示</h1>
    <img src="https://time.geekbang.org/sendcoin?user=hacker&number=100">
  </body>
</html>
```

#### 2.自动发起POST请求

用户打开黑客站点时，表单会被自动执行提交。

```js
<!DOCTYPE html>
<html>
<body>
  <h1>黑客的站点：CSRF攻击演示</h1>
  <form id='hacker-form' action="https://time.geekbang.org/sendcoin" method=POST>
    <input type="hidden" name="user" value="hacker" />
    <input type="hidden" name="number" value="100" />
  </form>
  <script> document.getElementById('hacker-form').submit(); </script>
</body>
</html>
```

#### 3.引诱用户点击链接

页面上半部分放一张图片，下面放有害下载地址诱使用户点击。

```js
<div>
  <img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg> </img> </div> <div>
  <a href="https://time.geekbang.org/sendcoin?user=hacker&number=100" taget="_blank">
    点击下载美女照片
  </a>
</div>
```

​	<font color=orange>**和XSS不同的是，CSRF攻击不需要将恶意代码注入用户的界面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。**</font>



### （2）防止CSRF攻击

CSRD攻击的三个必要条件：

- 目标站点一定要有CSRF漏洞；
- 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；
- 需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛；

满足以上条件才能进行CSRF攻击。与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说**<font color=orange>对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性</font>。**

#### 1.充分利用好 Cookie 的 SameSite 属性

- Cookie 是浏览器和服务器之间维护登录状态的一个关键数据，要阻止 CSRF 攻击首先就要在 Cookie 上做文章。

1. 如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；
2. 如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。

- 和设置HttpOnly一样，在Http响应头使用set-cookie设置Cookie字段时，可以带上 SameSite 选项，该属性有三个值。

1. **Strict 最为严格**，如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。
2.  **Lax 相对宽松**一点，在跨站点的情况下从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie，但是跨站Post方法或者img、iframe标签加载URL不会携带Cookie。
3. **None无限制**，在任何情况下都会发送 Cookie 数据。

#### 2.验证请求的来源站点

**在服务端验证请求来源的站点**，由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。

​	**Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址**。但在服务器端验证请求头中的 Referer 并不是太可靠，标准委员会又制定了 Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性。服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。

#### 3.CSRF Token

- 第一步，在浏览器向服务器发起请求时，服务器生成一个CSRF Token，是服务器生成的字符串，然后将该字符串植入到返回的页面中。
- 第二步，在浏览器端如果要发起请求需要带上页面中的 CSRF Token，服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。



## 4、安全沙箱

​	浏览器在开始阶段是单进程的，单进程架构是不稳定的。浏览器进程中的任意一个功能出现异常都有可能影响整个浏览器。

浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用**<font color=orange>缓冲区溢出</font>**。

- XSS攻击只是将恶意的JS脚本注入到页面中，虽然能窃取一些Cookie数据，但是无法对操作系统进行攻击；
- 通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，危害性更大。

### （1）安全视角下的多进程架构

![image-20220427180946970](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204271809631.png)

​	现代浏览器采用了多进程架构，浏览器被划分为**浏览器内核**和**渲染内核**两个核心模块，浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。

​	所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。



### （2）安全沙箱

​	由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞被黑客攻击，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限。

​	基于以上原因，需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。**<font color=orange>将渲染进程和操作系统隔离的这道墙就是安全沙箱</font>。**

​	安全沙箱最小的保护单位是进程，因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。



### （3）安全沙箱影响各模块功能

​	如果要让安全沙箱应用在某个进程上，那么这个进程**必须没有读写操作系统的功能**，比如读写本地文件、发起网络请求、调用 GPU 接口等。

![image-20220427182001055](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204271820642.png)

​	由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。

#### 1.持久存储

​	渲染进程内部有访问 Cookie 的需求、有上传文件的需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。

- 存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。
- 一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。

#### 2.网络访问

​	渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。

#### 3.用户交互

​	由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作**窗口句柄**的，这也是为了限制渲染进程监控到用户的输入事件。因此渲染进程需要完成两点改变：

1. 渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。
2. 操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。

所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。



### （4）站点隔离

​	Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。

​	如果一个标签页里面有多个不同源的 iframe，那么这些 iframe 也会被分配到同一个渲染进程中，这样就很容易让黑客通过 iframe 来攻击当前渲染进程。而站点隔离会将不同源的 iframe 分配到不同的渲染进程中，这样即使黑客攻击恶意 iframe 的渲染进程，也不会影响到其他渲染进程的。。

​	目前所有操作系统都面临着两个 A 级漏洞——幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。



#### 安全沙箱是不能防止 XSS 或者 CSRF 一类的攻击

安全沙箱的目的是隔离渲染进程和操作系统，让渲染进行没有访问操作系统的权利。

XSS 或者 CSRF 主要是利用网络资源获取用户的信息，这和操作系统没有关系的。



## 5、HTTPS

使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为**中间人攻击**。

![image-20220427183323467](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204271833918.png)

​	将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。

### （1）在HTTP协议栈中引入安全层

​	从 HTTP 协议栈层面来看，可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密。

![image-20220427183525084](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204271835438.png)

安全层有两个主要的职责：**<font color=orange>对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作</font>**。

#### 1.第一版：使用对称加密

所谓对称加密是指加密和解密都使用的是相同的密钥，第一版的加密，传输 client-random 和 service-random 的过程却是明文的，黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。

![image-20220427184156217](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204271841540.png)

#### 2.第二版：使用非对称加密

**非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。**

在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为**公钥**，服务器自己留下的那个密钥称为**私钥**。<font color=orange>公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开</font>。

非对称加密的效率太低，且无法保证服务器发送给浏览器的数据安全。

![image-20220427184310633](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204271843569.png)

#### 3.第三版：对称加密和非对称加密搭配使用

传输数据阶段依然使用对称加密，但是对称加密的密钥采用非对称加密来传输。

![image-20220427184325198](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204271843325.png)

pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。

#### 4.第四版：添加数字证书

能证明服务器是自己的服务器的权威机构称为CA，颁发的证书就称为数字证书。

数字证书有两个作用：

1. 一个是通过数字证书向浏览器证明服务器的身份；
2. 另一个是数字证书里面包含了服务器公钥。

![image-20220427184604525](https://raw.githubusercontent.com/Rainchen0504/picture/master/202204271846664.png)



### （2）申请证书

- 需要准备一套私钥和公钥，私钥留着自己使用；
- 向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；
- CA 通过线上、线下等多种渠道来验证所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；
- 如信息审核通过，CA 会签发认证的数字证书，包含了公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。

### （3）验证证书

- 当浏览器向服务器发出请求时，服务器会返回数字证书给浏览器；
- 浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，同时浏览器还会验证证书相关的域名信息、有效时间等信息。
- 浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。

