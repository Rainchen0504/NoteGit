## 1、冒泡排序

### （1）思路

1. 两两比较相邻的元素并交换它们的位置，从而使整个序列按照顺序排列；
2. 排完一次后，最大值总会在最后面，下次循环就不用考虑最大值；
3. 重复这样的操作，最后得到排序完成的数组；



### （2）流程

1. 从第一个元素开始，逐一比较相邻元素的大小；
2. 如果前一个比后一个元素大，交换位置；
3. 第一轮比较结束之后，最大的元素被移动到了最后一个位置；
4. 下一轮比较中不再考虑最后一个元素，重复操作；
5. 每轮比较结束后，需要排序的元素数量减一，直到没有需要排序的元素；
6. 排序结束；



### （3）图解

![image-20230224164446431](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302241644396.png)



### （4）复杂度

最坏情况下，时间复杂度为O(n^2)，在最好情况下，时间复杂度为O(n)



### （5）代码实现

```typescript
function bubbleSort (arr: number[]) :number[] {
  // 外层循环，控制比较次数
  for(let i = 0; i < arr.length - 1; i++){
    // 内层循环，控制每轮比较次数
    for(let j = 0; j < arr.length -1 - i; j++){
      // 前后比较
      if(arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr
}
const arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
bubbleSort(arr)
```



## 2、选择排序

### （1）思路

1. 首先在未排序的数列中找到最小（大）元素，然后将其存放到数列的起始位置；
2. 再从剩余未排序的元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；
3. 以此类推，直到所有元素均排序完毕；



### （2）流程

1. 首先将要排序的数组复制到一个新数组中，这样原数组不会被改变；
2. 初始化最小数字的索引为0，然后在数组中循环，在当前索引后面的元素中找到最小的数字的索引；
3. 如果当前索引位置的数字不是最小数字，那么将这两个数字互换；
4. 继续寻找下一个数字，直到索引到最后一个元素，此时整个数组已经是从小到大排序的了；
5. 重复上面的步骤，每次排序的范围都会减少一个，直到整个数组排序完毕；



### （3）图解

![image-20230224173007018](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302241730332.png)



### （4）复杂度

整个选择排序算法的时间复杂度是O(N^2)



### （5）代码实现

```typescript
function selectionSort(arr: number[]): number[] {
  // 循环遍历整个数组
  for (let i = 0; i < arr.length; i++) {
    // 预设最小数的索引为当前循环的索引
    let minIndex = i;
    // 在后面的数中寻找更小的数
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        // 如果找到更小的数，记录它的索引
        minIndex = j;
      }
    }
    // 如果当前循环的索引不是最小数的索引，交换它们
    if (i !== minIndex) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
  // 返回排序后的数组
  return arr;
}

// 测试数据
const testArr = [5, 2, 9, 1, 5, 6];
// 调用插入排序函数
const sortedArr = selectionSort(testArr);
```



## 3、插入排序

### （1）思路

1. 首先假设第一个数据是已经排好序的，接着取出下一个数据，在已经排好序的数据中从后往前扫描，找到比它小的数的位置，将该位置之后的数整体后移一个单位，然后再将该数插入到该位置。
2. 不断重复上述操作，直到所有的数据都插入到已经排好序的数据中，排序完成。



### （2）流程

1. 首先，假设数组的第一个元素已经排好序了，因为它只有一个元素，所以可以认为是有序的；
2. 然后，从第二个元素开始，不断与前面的有序数组元素进行比较；
3. 如果当前元素小于前面的有序数组元素，则把当前元素插入到前面的合适位置；
4. 否则，继续与前面的有序数组元素进行比较；
5. 以此类推，直到整个数组都有序；
6. 循环步骤2~5，直到最后一个元素，完成排序；



### （3）图解

![image-20230224175640524](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302241756768.png)



### （4）复杂度

性能比冒泡排序和选择排序要好。时间复杂度为O(n)，空间复杂度为O(1)。



### （5）代码实现

```typescript
function insertionSort(arr: number[]): number[] {
  // 对于数组的每一个元素，从它开始到0位置，比较该元素和前一个元素的大小
  for (let i = 1; i < arr.length; i++) {
    let current = arr[i];
    let j = i - 1;
    // 如果该元素小于前一个元素，那么前一个元素向后移动，并继续向前比较
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }
    // 如果该元素大于前一个元素，那么它将放到合适的位置
    arr[j + 1] = current;
  }
  // 返回排序后的数组
  return arr;
}

// 测试数据
const testArr = [5, 2, 9, 1, 5, 6];
// 调用插入排序函数
const sortedArr = insertionSort(testArr);
// 打印结果
console.log(sortedArr);
```





## 4、归并排序

### （1）思路

1. 首先在未排序的数列中找到最小（大）元素，然后将其存放到数列的起始位置；
2. 再从剩余未排序的元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；
3. 以此类推，直到所有元素均排序完毕；



### （2）流程

1. 首先将要排序的数组复制到一个新数组中，这样原数组不会被改变；
2. 初始化最小数字的索引为0，然后在数组中循环，在当前索引后面的元素中找到最小的数字的索引；
3. 如果当前索引位置的数字不是最小数字，那么将这两个数字互换；
4. 继续寻找下一个数字，直到索引到最后一个元素，此时整个数组已经是从小到大排序的了；
5. 重复上面的步骤，每次排序的范围都会减少一个，直到整个数组排序完毕；



### （3）图解

![image-20230224173007018](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302241730332.png)



### （4）复杂度

整个选择排序算法的时间复杂度是O(N^2)



### （5）代码实现

```typescript
function selectionSort(arr: number[]): number[] {
  // 循环遍历整个数组
  for (let i = 0; i < arr.length; i++) {
    // 预设最小数的索引为当前循环的索引
    let minIndex = i;
    // 在后面的数中寻找更小的数
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        // 如果找到更小的数，记录它的索引
        minIndex = j;
      }
    }
    // 如果当前循环的索引不是最小数的索引，交换它们
    if (i !== minIndex) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
  // 返回排序后的数组
  return arr;
}

// 测试数据
const testArr = [5, 2, 9, 1, 5, 6];
// 调用插入排序函数
const sortedArr = selectionSort(testArr);
```





## 5、快速排序

### （1）思路

1. 首先在未排序的数列中找到最小（大）元素，然后将其存放到数列的起始位置；
2. 再从剩余未排序的元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；
3. 以此类推，直到所有元素均排序完毕；



### （2）流程

1. 首先将要排序的数组复制到一个新数组中，这样原数组不会被改变；
2. 初始化最小数字的索引为0，然后在数组中循环，在当前索引后面的元素中找到最小的数字的索引；
3. 如果当前索引位置的数字不是最小数字，那么将这两个数字互换；
4. 继续寻找下一个数字，直到索引到最后一个元素，此时整个数组已经是从小到大排序的了；
5. 重复上面的步骤，每次排序的范围都会减少一个，直到整个数组排序完毕；



### （3）图解

![image-20230224173007018](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302241730332.png)



### （4）复杂度

整个选择排序算法的时间复杂度是O(N^2)



### （5）代码实现

```typescript
function selectionSort(arr: number[]): number[] {
  // 循环遍历整个数组
  for (let i = 0; i < arr.length; i++) {
    // 预设最小数的索引为当前循环的索引
    let minIndex = i;
    // 在后面的数中寻找更小的数
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        // 如果找到更小的数，记录它的索引
        minIndex = j;
      }
    }
    // 如果当前循环的索引不是最小数的索引，交换它们
    if (i !== minIndex) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
  // 返回排序后的数组
  return arr;
}

// 测试数据
const testArr = [5, 2, 9, 1, 5, 6];
// 调用插入排序函数
const sortedArr = selectionSort(testArr);
```





### 1、归并排序

```javascript
//归并排序
//先拆分数组为一项一项的形式，再两两比较合并
let mergeSort = function (arr) {
  //如果元素小于2个，则无需排序，直接返回
  if (arr.length < 2) {
    return arr;
  }
  // 2. 获取数组中间值，无需取整，splice 会以向下取整截取
  let mid = arr.length / 2;
  // 3. 截取数组前一半
  let left = arr.splice(0, mid);
  // 4. 剩余为数组右半边
  let right = arr;
  // 5. 返回合并和排序后的数组
  return merge(mergeSort(left), mergeSort(right));
};

// 对数组进行排序并合并
let merge = function (left, right) {
  //中间变量，存储比较结果较小的值
  let stack = [];
   // 当有一个数组为空之后，则停止循环
  while (left.length && right.length) {
    // 从左右子数组的最小元素中选择较小的元素 push 到 stack 中
    if (left[0] > right[0]) {
      stack.push(right.shift());
    } else {
      stack.push(left.shift());
    }
  }
  return [...stack, ...left, ...right];
};

console.log(mergeSort([8, 4, 3, 6, 1, 7, 89, 6]));
```

![image-20220824174029388](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241740812.png)



### 2、快速排序

```javascript
var quickSort = function (arr) {
  if (arr.length < 2) {
    return arr;
  }
  let left = [];
  let right = [];
  let current = arr.splice(0, 1);
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < current) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat(current, quickSort(right));
};

console.log(quickSort([8, 4, 3, 6, 1, 7, 89, 6]));
```

![image-20220824174201189](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241742978.png)

![image-20220824174211613](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241742862.png)

![image-20220824174222490](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241742725.png)
