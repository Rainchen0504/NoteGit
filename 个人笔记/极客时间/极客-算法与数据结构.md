## 一、数据结构与算法总结

![](https://raw.githubusercontent.com/Rainchen0504/picture/master/202110031933929.webp)



## 二、常用、基础的数据结构与算法



### 1、算法

​	递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法



### 2、数据结构

​	数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、trie树；



## 三、时间、空间复杂度分析

### 1、大O时间复杂度表示法

​	每一行代码都执行了类似的操作：读数据--运算--写数据。所有的代码的执行时间T(n)与每行代码的执行次数成正比。总结公式如下：

```javascript
T(n) = O(f(n))
//T(n)代表执行的时间；
//n表示数据规模的大小；
//f(n)表示每行执行代码的次数总和；
//公式中O，表示代码执行时间T(n)与f(n)表达式成正比；
```

​	大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫**渐进时间复杂度**，简称**时间复杂度**。



### 2、时间复杂度分析方法

#### （1）只关注循环执行次数最多的一段代码

#### （2）加法法则：总复杂度等于量级最大的那段代码的复杂度

#### （3）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积



### 3、常见时间复杂度分析案例

![img](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg)

复杂度量级可以粗略的分为两类：**多项式量级和非多项式量级**。

#### （1）O(1)

```c
 int i = 8;
 int j = 6;
 int sum = i + j;
```

​	O(1)只是常量级时的事件复杂度表示方法，并不是只执行了一行代码。一般情况下，只要算法中<font color=red>不存在循环语句、递归语句</font>，**即使有成千上万行的代码，其时间复杂度也是Ο(1)。**



#### （2）O(logn)、O(nlogn)

​	O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

```c
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

第三行代码循环次数最多，只要能计算出这行代码被执行了多少次，就能知道整段代码的复杂度。从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。

<img src="https://raw.githubusercontent.com/Rainchen0504/picture/master/202112151703743.png" alt="image-20211215170318745" style="zoom:50%;" />

通过 2x=n求解x这个问题x=log2n，这段代码的时间复杂度就是 O(log2n)。

在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，<font color=red>在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</font>



#### （3）O(m+n)、O(m*n)

代码的复杂度由**两个数据的规模**来决定：

```c
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

m和n表示两个数据规模，无法评估m和n哪个量级大，所以复杂度为O(m+n)，乘法法则同样有效O(m*n)。



### 4、空间复杂度分析

​	时间复杂度全程是**渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系**。类比一下，空间复杂度全称就是渐进空间复杂度，<font color=red>表示算法的存储空间与数据规模之间的增长关系。</font>

​	我们**常见的空间复杂度就是 O(1)、O(n)、O(n2 )**，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。



### 总结

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率和数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。

常见的复杂度并不多，从<font color=red>低阶到高阶</font>有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。

<img src="https://raw.githubusercontent.com/Rainchen0504/picture/master/202112151713805.png" alt="image-20211215171301319" style="zoom:50%;" />



### 5、最好、最坏情况时间复杂度

```c
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

​	上面代码实现了一个无序的数组中，查找变量x出现的位置，找不到就返回-1。但是上面代码的复杂度不是O(n)。要查找的变量 x 可能出现在数组的任意位置。第一个就是O(1)，不存在就是O(n)。

​	顾名思义，<font color=red>**故名思义，最好情况复杂度就是理想情况下的恶复杂度。最坏情况复杂度就是最糟糕情况下的时间复杂度。**</font>



### 6、平均情况时间复杂度

​	还是用上面的例子分析，要查找x在数组中的位置，有n+1种情况：**在数组的0～n-1位置种和不在数组中**。

​	把需要遍历的元素的个数累加起来然后再处以n+1，就可以得到需要遍历的元素个数的平均值

<img src="https://raw.githubusercontent.com/Rainchen0504/picture/master/202112151729337.png" alt="image-20211215172854598" style="zoom:50%;" />

时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。

但是这种计算方法有点问题，没有将每种情况发生的概率考虑进去。

**假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。**

如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：

<img src="https://raw.githubusercontent.com/Rainchen0504/picture/master/202112151739005.png" alt="image-20211215173936014" style="zoom:50%;" />

这个值就是概率论中的**加权平均值**，也叫作**期望值**，所以<font color=red>**平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度**。</font>



### 7、均摊时间复杂度（摊还分析）



## 四、数组

### 1、如何实现随机访问

数组：数组（Array）是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组**具有相同类型的数据**。

