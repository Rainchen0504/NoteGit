### 1、归并排序

```javascript
//归并排序
//先拆分数组为一项一项的形式，再两两比较合并
let mergeSort = function (arr) {
  //如果元素小于2个，则无需排序，直接返回
  if (arr.length < 2) {
    return arr;
  }
  // 2. 获取数组中间值，无需取整，splice 会以向下取整截取
  let mid = arr.length / 2;
  // 3. 截取数组前一半
  let left = arr.splice(0, mid);
  // 4. 剩余为数组右半边
  let right = arr;
  // 5. 返回合并和排序后的数组
  return merge(mergeSort(left), mergeSort(right));
};

// 对数组进行排序并合并
let merge = function (left, right) {
  //中间变量，存储比较结果较小的值
  let stack = [];
   // 当有一个数组为空之后，则停止循环
  while (left.length && right.length) {
    // 从左右子数组的最小元素中选择较小的元素 push 到 stack 中
    if (left[0] > right[0]) {
      stack.push(right.shift());
    } else {
      stack.push(left.shift());
    }
  }
  return [...stack, ...left, ...right];
};

console.log(mergeSort([8, 4, 3, 6, 1, 7, 89, 6]));
```

![image-20220824174029388](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241740812.png)



### 2、快速排序

```javascript
var quickSort = function (arr) {
  if (arr.length < 2) {
    return arr;
  }
  let left = [];
  let right = [];
  let current = arr.splice(0, 1);
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < current) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat(current, quickSort(right));
};

console.log(quickSort([8, 4, 3, 6, 1, 7, 89, 6]));
```

![image-20220824174201189](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241742978.png)

![image-20220824174211613](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241742862.png)

![image-20220824174222490](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241742725.png)
