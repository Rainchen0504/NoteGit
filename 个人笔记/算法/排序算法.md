复杂度图例

![image-20230228204140947](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302282041699.png)





## 1、冒泡排序

### （1）思路

1. 两两比较相邻的元素并交换它们的位置，从而使整个序列按照顺序排列；
2. 排完一次后，最大值总会在最后面，下次循环就不用考虑最大值；
3. 重复这样的操作，最后得到排序完成的数组；



### （2）流程

1. 从第一个元素开始，逐一比较相邻元素的大小；
2. 如果前一个比后一个元素大，交换位置；
3. 第一轮比较结束之后，最大的元素被移动到了最后一个位置；
4. 下一轮比较中不再考虑最后一个元素，重复操作；
5. 每轮比较结束后，需要排序的元素数量减一，直到没有需要排序的元素；
6. 排序结束；



### （3）图解

![image-20230224164446431](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302241644396.png)



### （4）复杂度

最坏情况下，时间复杂度为O(n^2)，在最好情况下，时间复杂度为O(n)



### （5）代码实现

```typescript
function bubbleSort (arr: number[]) :number[] {
  // 外层循环，控制比较次数
  for(let i = 0; i < arr.length - 1; i++){
    // 内层循环，控制每轮比较次数
    for(let j = 0; j < arr.length -1 - i; j++){
      // 前后比较
      if(arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr
}
const arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
bubbleSort(arr)
```



## 2、选择排序

### （1）思路

1. 首先在未排序的数列中找到最小（大）元素，然后将其存放到数列的起始位置；
2. 再从剩余未排序的元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；
3. 以此类推，直到所有元素均排序完毕；



### （2）流程

1. 首先将要排序的数组复制到一个新数组中，这样原数组不会被改变；
2. 初始化最小数字的索引为0，然后在数组中循环，在当前索引后面的元素中找到最小的数字的索引；
3. 如果当前索引位置的数字不是最小数字，那么将这两个数字互换；
4. 继续寻找下一个数字，直到索引到最后一个元素，此时整个数组已经是从小到大排序的了；
5. 重复上面的步骤，每次排序的范围都会减少一个，直到整个数组排序完毕；



### （3）图解

![image-20230224173007018](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302241730332.png)



### （4）复杂度

整个选择排序算法的时间复杂度是O(N^2)



### （5）代码实现

```typescript
function selectionSort(arr: number[]): number[] {
  // 循环遍历整个数组
  for (let i = 0; i < arr.length; i++) {
    // 预设最小数的索引为当前循环的索引
    let minIndex = i;
    // 在后面的数中寻找更小的数
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        // 如果找到更小的数，记录它的索引
        minIndex = j;
      }
    }
    // 如果当前循环的索引不是最小数的索引，交换它们
    if (i !== minIndex) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
  // 返回排序后的数组
  return arr;
}

// 测试数据
const testArr = [5, 2, 9, 1, 5, 6];
// 调用插入排序函数
const sortedArr = selectionSort(testArr);
```



## 3、插入排序

### （1）思路

1. 首先假设第一个数据是已经排好序的，接着取出下一个数据，在已经排好序的数据中从后往前扫描，找到比它小的数的位置，将该位置之后的数整体后移一个单位，然后再将该数插入到该位置。
2. 不断重复上述操作，直到所有的数据都插入到已经排好序的数据中，排序完成。



### （2）流程

1. 首先，假设数组的第一个元素已经排好序了，因为它只有一个元素，所以可以认为是有序的；
2. 然后，从第二个元素开始，不断与前面的有序数组元素进行比较；
3. 如果当前元素小于前面的有序数组元素，则把当前元素插入到前面的合适位置；
4. 否则，继续与前面的有序数组元素进行比较；
5. 以此类推，直到整个数组都有序；
6. 循环步骤2~5，直到最后一个元素，完成排序；



### （3）图解

![image-20230224175640524](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302241756768.png)



### （4）复杂度

性能比冒泡排序和选择排序要好。时间复杂度为O(n)，空间复杂度为O(1)。



### （5）代码实现

```typescript
function insertionSort(arr: number[]): number[] {
  // 对于数组的每一个元素，从它开始到0位置，比较该元素和前一个元素的大小
  for(let i = 1; i <arr.length; i++) {
    let current = arr[i];
    let j = i - 1;
    while(j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j]
      j--
    }
    // 如果该元素大于前一个元素，那么将放到合适的位置
    arr[j + 1] = current
  }
  return arr
}
```





## 4、归并排序

### （1）思路

1. 将待排序数组分成若干个子数组；
2. 将相邻的子数组归并成一个有序的数组；
3. 然后再把有序数组归并成一个整体有序的数组



### （2）流程

1. 分解
   1. 如果待排序数组长度为1，认为这个数组已经有序，直接返回；
   2. 将待排序数组分成两个长度相等的子数组，分别对这两个子数组进行递归排序；
   3. 两个排好序的子数组合并成一个有序数组，返回这个有序数组；
2. 合并
   1. 合并过程中，需要比较每个子数组的元素并将它们有序地合并成一个新的数组；
   2. 可以使用两个指针 i 和 j 分别指向两个子数组的开头，比较它们的元素大小，并将小的元素插入到新的有序数组中；
   3. 如果其中一个子数组已经遍历完，就将另一个子数组的剩余部分直接插入到新的有序数组中；
   4. 最后返回这个有序数组；
3. 归并终止条件
   1. 当子数组的长度为1时，认为这个子数组已经有序，递归结束；



### （3）图解

![图片](https://raw.githubusercontent.com/Rainchen0504/picture/master/202302282038381.png)



### （4）复杂度

最好情况**O(log n)**

待排序数组已经是有序的了，那么每个子数组都只需要合并一次，即只需要进行一次归并操作，时间复杂度是 O(log n)



最坏情况**O(nlogn)**

待排序数组是逆序的，那么每个子数组都需要进行多次合并，时间复杂度为 O(nlogn)



平均情况**O(nlogn)**



### （5）代码实现

```typescript
// 定义函数mergeSort，参数是待排序数组arr
function mergeSort(arr: number[]): number[] {
    // 计算数组长度
    const n = arr.length;
    // 如果数组长度小于等于1，则直接返回该数组
    if (n <= 1) {
        return arr;
    }
    // 计算中间位置
    const middle = Math.floor(n / 2);
    // 对左边的数组进行归并排序
    const left = mergeSort(arr.slice(0, middle));
    // 对右边的数组进行归并排序
    const right = mergeSort(arr.slice(middle));
    // 合并两个排好序的数组
    return merge(left, right);
}

// 定义函数merge，参数是两个排好序的数组left和right
function merge(left: number[], right: number[]): number[] {
    // 定义指针变量，分别指向两个数组的开头
    let i = 0, j = 0;
    // 定义一个空数组，用来存放合并后的数组
    const result = [];
    // 比较两个数组的第一个元素，将较小的放入result数组
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    // 将没有比较完的剩余元素放入result数组
    while (i < left.length) {
        result.push(left[i++]);
    }
    while (j < right.length) {
        result.push(right[j++]);
    }
    // 返回合并后的数组
    return result;
}


// 测试数据
const testArr = [5, 2, 9, 1, 5, 6];
// 调用插入排序函数
const sortedArr = mergeSort(testArr);
// 打印结果
console.log(sortedArr);
```

1、mergeSort

函数实现归并排序的递归调用，在该函数内，如果数组的长度小于等于1，直接返回该数组。

如果数组的长度大于1，那么执行以下代码：

- 先计算数组的中点，并将数组分为左右两半；
- 递归调用左边和右边的数组，最终得到两个有序的数组；

2、merge

函数实现将两个有序的数组合并为一个有序的数组；



## 5、快速排序

### （1）思路

将数组划分为两个子数组，每个子数组再分别进行排序，最终实现整个数组的排序；



### （2）流程

1. 首先选择一个基准元素，通常选择第一个或者最后一个元素作为基准；
2. 定义两个指针 i 和 j ，分别指向数组的左右两端；
3. 从右侧开始，向左移动 j 指针，直到找到一个小于或等于基准元素的值；
4. 从左侧开始，向右移动 i 指针，直到找到一个大于或等于基准元素的值；
5. 如果 i 指针小于或等于 j 指针，交换 i 和 j 指针所指向的元素；
6. 重复步骤 3-5，直到 i 指针大于 j 指针，这时将基准元素与 j 指针所指向的元素交换位置，将基准元素放到中间位置；
7. 将数组分为两部分，左侧部分包含小于或等于基准元素的元素，右侧部分包含大于基准元素的元素；
8. 对左右两部分分别进行递归调用快速排序，直到左右两部分只剩下一个元素；
9. 最后整个数组就变得有序了；



### （3）图解

![图片](https://raw.githubusercontent.com/Rainchen0504/picture/master/202303012044601.png)



### （4）复杂度

时间复杂度： 快速排序是一种分治思想的排序算法，它的时间复杂度取决于基准数的选取。

- 最坏情况下，每次选取的基准数为序列中的最大或最小数，导致划分的两部分长度不平均，递归的次数将会达到O(n)，因此时间复杂度为O(n^2)
- 最优情况下，每次选取的基准数将整个序列划分成两个长度大致相等的部分，递归的次数将会达到log2n，因此时间复杂度为O(nlogn)

空间复杂度：快速排序是一种原地排序算法，它不需要额外的存储空间。

- 在递归过程中，空间复杂度仅为递归调用的栈空间，因此空间复杂度为O(logn)



### （5）代码实现

```typescript
function quickSort(array: number[]): number[] {
  if (array.length < 2) {
    return array;
  }
  let left: number[] = [];
  let right: number[] = [];
  let current: number[] = array.splice(0, 1);
  for (let i = 0; i < array.length; i++) {
    if (array[i] < current[0]) {
      left.push(array[i]);
    } else {
      right.push(array[i]);
    }
  }
  return quickSort(left).concat(current, quickSort(right));
}

console.log(quickSort([8, 4, 3, 6, 1, 7, 89, 6]));
```



## 6、堆排序









## 1、归并排序

```javascript
//归并排序
//先拆分数组为一项一项的形式，再两两比较合并
let mergeSort = function (arr) {
  //如果元素小于2个，则无需排序，直接返回
  if (arr.length < 2) {
    return arr;
  }
  // 2. 获取数组中间值，无需取整，splice 会以向下取整截取
  let mid = arr.length / 2;
  // 3. 截取数组前一半
  let left = arr.splice(0, mid);
  // 4. 剩余为数组右半边
  let right = arr;
  // 5. 返回合并和排序后的数组
  return merge(mergeSort(left), mergeSort(right));
};

// 对数组进行排序并合并
let merge = function (left, right) {
  //中间变量，存储比较结果较小的值
  let stack = [];
   // 当有一个数组为空之后，则停止循环
  while (left.length && right.length) {
    // 从左右子数组的最小元素中选择较小的元素 push 到 stack 中
    if (left[0] > right[0]) {
      stack.push(right.shift());
    } else {
      stack.push(left.shift());
    }
  }
  return [...stack, ...left, ...right];
};

console.log(mergeSort([8, 4, 3, 6, 1, 7, 89, 6]));
```

![image-20220824174029388](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241740812.png)



## 2、快速排序

```javascript
var quickSort = function (arr) {
  if (arr.length < 2) {
    return arr;
  }
  let left = [];
  let right = [];
  let current = arr.splice(0, 1);
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < current) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat(current, quickSort(right));
};

console.log(quickSort([8, 4, 3, 6, 1, 7, 89, 6]));
```

![image-20220824174201189](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241742978.png)

![image-20220824174211613](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241742862.png)

![image-20220824174222490](https://raw.githubusercontent.com/Rainchen0504/picture/master/202208241742725.png)
