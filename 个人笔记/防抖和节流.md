## 一、防抖

​	高频率触发的事件，在指定的<font color=red>单位时间内只响应最后一次</font>，如果在指定的时间内触发，则重新计算时间（后面触发的事件执行，替代了前面的事件）

```html
<div style="height: 2000px;width: 300px;background-color: red;"></div>
<script>
  function debounce(fn, delay) {
    let timer = null; // 创建一个标记用来存放定时器的返回值
    return function () {
      clearTimeout(timer)//每当用户操作的时候把前一个 setTimeout clear 掉
      timer = setTimeout(fn, delay) //然后又创建一个新的 setTimeout, 这样就能保证滚动鼠标delay间隔内如果还有滚动的话，就不会执行fn函数
    }
  }
  // 打印鼠标位置的事件
  function showTop() {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    console.log('滚动条位置：' + scrollTop);
  }
  window.onscroll = debounce(showTop, 1000)
</script>
```



```js
//手写防抖，防抖就是短时间触发的函数，只执行最后一次
//防抖函数体
function debounce(fn,delay){
  var timer = null;
  return function(){
    var context = this;
    var args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function(){
      fn.apply(context,args);
    },delay)
  }
}
//执行函数
function res(){
  console.log("执行函数")
}
//点击事件1秒后触发
windouw.addEventListener('click',debounce(res,2000));
```





## 二、节流

​	高频率触发的事件,在指定的单位时间内，只响应单位时间的第一次(前面触发的执行前，忽略后面的事件)

```html
<div style="height: 2000px;width: 300px;background-color: red;"></div>
<script>
  function throttle(fn, delay) {
    let valid = true //通过闭包保存一个标记;
    return function () {
      if (!valid) {return false};//在函数开头判断标记是否为true，不为true则return
      valid = false//立即设为false
      // 工作时间，执行函数并且在间隔期内把状态位设为无效
      setTimeout(() => {//将外部传入的函数的执行放在setTimeout中
        fn()
        // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
        valid = true;
      }, delay)
    }
  }
  /* 请注意，节流函数并不止上面这种实现方案,
           例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。
           也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样*/
  function showTop() {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    console.log('滚动条位置：' + scrollTop);
  }
  window.onscroll = throttle(showTop, 1000)
</script>
```



```js
//手写节流，节流是一段时间内只执行一次，而防抖是只执行最后一次
//防抖函数体
function throttle(fn,delay){
  //初始化timer
  var timer = null;
  return function(){
    var context = this;
    var args = arguments;
    if(!timer){
      timer = setTimeout(function(){
        fn.apply(context,args);
        timer = null;
      },delay);
    }
  }
}
//执行函数
function res(){
  console.log("执行函数")
}
//2秒内只执行一次
windouw.addEventListener('click',throttle(res,2000));
```



```js
function throttle(fn,delay){
  var p =Date.now();
  return function(){
    let context=this;
    let args=arguments;
    let n=Date.now();
    if(n-p>=delay){
      fn.apply(context,args);
      p =Date.now();
    }
  };
}
function res(){
  console.log('触发事件');
}
window.addEventListener('resize',throttle(res,2000));
```



## 三、应用场景

1. #### <font color=red>搜索框input事件</font>，例如要支持输入实时搜索可以使用<font color=red>节流</font>方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。

2. #### <font color=red>页面resize事件</font>，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用<font color=red>防抖</font>，因为只需要判断最后一次的变化情况）

3.一题一页高频点击使用节流