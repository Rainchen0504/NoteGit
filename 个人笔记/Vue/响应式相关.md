# 一、ref解析



## 1、基本数据类型（`strRef`）

![image-20230306211352437](https://raw.githubusercontent.com/Rainchen0504/picture/master/202303062113756.png)



## 2、引用数据类型（`arrRef、ObjRef`）

### （1）数组arrRef

![image-20230306211432838](https://raw.githubusercontent.com/Rainchen0504/picture/master/202303062114843.png)



### （2）对象ObjRef

![image-20230306211448665](https://raw.githubusercontent.com/Rainchen0504/picture/master/202303062114346.png)



### （3）`RefImpl`对象

任何类型的数据都是一个**`RefImpl`**对象（引用实现的简写reference implement），该对象有6个属性：

1. `dep`：是一个Set结构，存储当前的ref值收集的依赖；
2. `__v_isRef`：标记位，只要被ref定义，值为true；
3. `__v_isShallow`：是否是`shallowRef`定义的属性（浅层响应，修改深层数据不具备响应性）；
4. `_rawValue`：保存当前ref值对应的原始值，否则_ value与_ rawValue相同；
5. `_value`：保存ref当前值，如果传递的参数是对象，就是保存经过reactive函数转化后的值；
6. `value`：当前的值；



### （4）源码处理过程

#### 4.1、ref函数

`Vue3`向开发者暴露的是`ref`函数，封装了一个`createRef`函数。

```js
export function ref(value?: unknown) {
	return createRef(value, false)
}
```



#### 4.2、createRef函数

`createRef`函数：接收两个参数。判断当前`rawValue`是否是`ref`类型的数据，创建`RefImpl`实例对象。

```js
// 参数一：要做相应处理的数据
// 参数二：判断数据是否为shallowRef定义的数据
function createRef(rawValue: unknown, shallow: boolean) {
  if (isRef(rawValue)) {
    return rawValue
  }
  return new RefImpl(rawValue, shallow)
}
```



#### 4.3、RefImpl类

创建`RefImpl`类给`_rawValue`和`_value`属性赋值，判断当前定义的ref数据是否为shallowRef定义的数据，然后获取响应性值时对数据依赖进行收集并返回_ value，修改响应式值时修改并通知依赖更新。

**ref定义的数据为什么需要带.value调用数据**： <font color=pink>因为RefImpl类暴露给实例对象的get、set方法是value</font>

```js
class RefImpl<T> {
  private _value: T
  private _rawValue: T
  public dep?: Dep = undefined // 订阅者
  public readonly __v_isRef = true // ref标识
  constructor(value: T, public readonly __v_isShallow: boolean) {
    // 判断是否是shallowRef定义的数据，不是就进行toRaw转换成没有响应式的原始值
    this._rawValue = __v_isShallow ? value : toRaw(value)
    // 判断是否是shallowRef定义的数据，不是就进行toReactive转换成响应式数据
    this._value = __v_isShallow ? value : toReactive(value)
  }
  get value() {
    trackRefValue(this) // 依赖收集
    return this._value
  }
  set value(newVal) {
    // 把newVal的格式转换为与_rawValue一致的进行比较
    newVal = this.__v_isShallow ? newVal : toRaw(newVal)
    // 判断旧值和新值是否发生改变
    if (hasChanged(newVal, this._rawValue)) {
      // 改变就重新赋值
      this._rawValue = newVal
      // 如果是引用类型的新值，设置为响应式的
      this._value = this.__v_isShallow ? newVal : toReactive(newVal)
      // 通知依赖更新
      triggerRefValue(this, newVal)
    }
  }
}
```



# 二、reactive解析

## 1、包装类型

使用reactive封装的数据返回的**都是个`proxy`对象**，该对象有两个属性：要代理的对象和操作代理的行为函数。

![image-20230307112721620](https://raw.githubusercontent.com/Rainchen0504/picture/master/202303071127962.png)

代理对象的`Handler`属性值为对象，对象中包含5个属性：`deleteProperty、get、set、has、ownKeys`。



## 2、源码处理过程

### （1）`reactive`方法

```typescript
// vue3源码包喽的
export function reactive(target: Object) {
	// 判断target是否是只读的，只读不做处理
  if (isReadonly(target)) {
    return target
  }
  return createReactiveObject (
  	target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
}
```

`createReactiveObject`函数目的是为了创建`Proxy`实例对象，参数传递了5个属性：`target`（目标数据）、`isReadonly`（target是否只读）、`mutableHandlers`(ProxyHandlers)、`mutableCollectionHandlers`(ProxyHandler类型)、`reactiveMap`（数据集合）



### （2）`createReactiveObject`实例方法

```typescript
function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>,
  proxyMap: WeakMap<Target, any>
) {
    // 判断是否是对象，如果不是不做处理
  if (!isObject(target)) {
    if (__DEV__) {
      console.warn(`value cannot be made reactive: ${String(target)}`)
    }
    return target
  }
  // 判断原始target是否存在、是否只读、是否是响应式包装的
  if (
    target[ReactiveFlags.RAW] &&
    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
  ) {
    return target
  }
  // 判断当前target是否是proxy对象
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  // 获取当前target的数据类型
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) {
    return target
  }
  // 创建Proxy属性
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )
  proxyMap.set(target, proxy)
  return proxy
}
```



### （3）内置方法解析

#### 3.1、ReactiveFlags

响应式标记

```typescript
export const enum ReactiveFlags {
  SKIP = '__v_skip',// 标记对象不可进行代理
  IS_REACTIVE = '__v_isReactive',// 是否是Reactive封装的
  IS_READONLY = '__v_isReadonly',// 是否只读
  IS_SHALLOW = '__v_isShallow',// 是否是shallowRef封装的
  RAW = '__v_raw'// 是否是proxy原始的target
}
```



#### 3.2、targetType

代理数据类型

```typescript
const enum TargetType {
  INVALID = 0,
  COMMON = 1,// Array、Object类型
  COLLECTION = 2 // Set、Map、WaekMap、WeakSet类型
}
```



#### 3.3、baseHandlers

对于Array、Object类型数据，Proxy实例的第二个参数。传入的baseHandlers就是`mutableHandlers`。这个函数主要是为了给Proxy对象带上五个属性

```typescript
export const mutableHandlers: ProxyHandler<object> = {
  // createGetter() 主要实现依赖收集和Reflect.set(target, key, value, receiver)
  get,
  // createSetter() 主要实现通知依赖更新和Reflect.get(target, key, receiver)
  set,
  // deleteProperty() 主要是删除target的指定key的属性Reflect.deleteProperty(target, key)
  deleteProperty,
  // has() 主要是判断target是否存在指定key的属性，Reflect.has(target, key)
  has,
  // ownKeys() 主要是获取target的key数组，Reflect.ownKeys(target)
  ownKeys
}
```



#### 3.4、collectionHandlers

对于Set、Map、WaekMap、WeakSet类型数据，Proxy实例的第二个参数。传入的baseHandlers就是`mutableCollectionHandlers`。mutableCollectionHandlers主要是对 set、map、weakSet、weakMap 四种类型的对象进行劫持。

```typescript
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: /*#__PURE__*/ createInstrumentationGetter(false, false)
}
function createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {
  const instrumentations = shallow? 
    isReadonly? shallowReadonlyInstrumentations: shallowInstrumentations
    : isReadonly? readonlyInstrumentations: mutableInstrumentations

  return (target: CollectionTypes,key: string | symbol,receiver: CollectionTypes) => {
    ...
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target? instrumentations:target,
      key,
      receiver
    )
  }
}
```



# 总结

## 1、ref

定义基本数据类型、引用数据类型的响应式。封装数据类型为ref类型，主要就是`创建了RefImpl实例对象`。

## 2、reactive

定义引用类型数据的响应式，不支持基本数据类型，如果需要写基本数据类型只能是放在对象中。封装数据为reactive类型，主要是`创建了Proxy实例对象`，通过Reflect实现数据的获取与修改。


