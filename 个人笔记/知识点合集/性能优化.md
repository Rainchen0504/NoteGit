# 性能优化方向：

1. 网络方向；
2. 页面渲染优化；
3. JS优化；
4. 图片优化；
5. webpack打包优化；
6. React优化；
7. Vue优化；



## 一、网络优化

### 1、DNS预解析

link标签的`rel`属性设置为`dns-prefetch`，提前获取域名对应的IP地址；



### 2、使用缓存

可以减轻服务端压力，从而快速得到数据，浏览器缓存机制分为强缓存和协商缓存。

1. 强缓存不需要向客户端发送请求，有两种响应头实现方案：
   1. `Expires`值是一个绝对时间，在这个时间前缓存有效，但是如果修改本地时间，会导致缓存失效；
   2. `Cache-control`值是一个相对时间，单位为秒，资源这个时间内有效；
2. 强缓存过期后会使用协商缓存，协商缓存需要客户端向服务端发送请求，资源未过期则返回304状态码，否则返回新的资源，协商缓存也有两种响应头实现方案：
   1. `Last-Modified` 和 `If-Modified-Since`：`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果本地文件被打开，会导致`Last-Modified` 被修改。
   2. `ETag` 和 `If-None-Match`：`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高



### 3、使用CDN内容分发网络

用户与服务器的物理距离对响应时间也有影响。而内容分发网络（CDN）是一组分散在不同地理位置的 web 服务器，用来给用户更高效地发送内容。



### 4、压缩响应

压缩组件通过减少HTTP请求产生的响应包的大小，从而降低传输时间的方式来提高性能。

从 HTTP1.1 开始，Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持。Web 服务器通过响应中的 `Content-Encoding` 头来告知 Web 客户端使用哪种方法进行的压缩。



### 5、使用多个域名

Chrome 等现代化浏览器，都会有同域名限制并发下载数的情况，不同的浏览器及版本都不一样，使用不同的域名可以最大化下载线程，但注意保持在 2~4 个域名内，以避免 DNS 查询损耗。



### 6、避免图片src为空

虽然 src 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求。IE 向页面所在的目录发送请求； Safari、Chrome、Firefox 向页面本身发送请求； Opera 不执行任何操作。



## 二、页面渲染优化

### 1、避免CSS阻塞

CSS影响渲染流程中布局树的构建，会阻塞页面的渲染，因此应该尽早和尽快将CSS资源加出来。

常有手段包括：将CSS引入过程放在head标签，使用CDN加载资源；



### 2、降低CSS选择器复杂度

1. 减少选择器嵌套，尽量不要超过三层，后代选择器开销较高，慎用；
2. 避免使用通配符，仅对用到的元素进行匹配即可；
3. 使用继承手段避免重复匹配定义样式；
4. 正确使用类选择器和id选择器；



### 3、避免使用CSS表达式

CSS表达式会频繁的进行计算，消耗性能；



### 4、避免JS阻塞

因为JS是单线程的脚本语言，且JS可以修改CSS和DOM，所以JS在加载执行过程中过程中会阻塞页面的渲染，JS会抢走渲染引擎的控制权。

所以在加载JS脚本的时候，一般使用async或defer方法优化脚本加载

- defer

  异步加载脚本，但不会立即执行，当HTML解析完成后，再按照在HTML中出现的顺序依次执行；

- async

  异步加载脚本，不会阻塞HTML解析，也不会等待其他脚本的加载，一旦下载完成立即执行，无法保证执行顺序；



### 5、使用外链式的JS和CSS

浏览器会缓存外部的JS和CSS文件，缓存可以减少请求资源的大小从而提升效率。而内联的代码不会被缓存，每次请求时都会下载内联的资源，增加请求负担。

同时使用外链资源还可以使用压缩工具对外链文件进行压缩，可以减小文件大小，加快页面加载速度。



### 6、使用字体图表替代图表

图片会增加网络请求次数，拖慢网页加载时间，而图标可以缩放且不会增加额外请求；



### 7、首屏加载优化

使用骨架屏或者动画优化用户体验；

资源按需加载，不需要的资源懒加载；



### 8、减少重绘和回流

1. 使用`documentFragment`

   增加多个节点使用`documentFragment`，升成的节点不是真实dom，不会引起重绘和回流；

   ```html
   <ul id="list"></ul>
   <script>
     const list = document.querySelector('#list')
     const fruits = ['Apple', 'Orange', 'Banana', 'Melon']
     const fragment = new DocumentFragment()
     fruits.forEach((fruit) => {
       const li = document.createElement('li')
       li.textContent = fruit
       fragment.appendChild(li)
     })
     list.appendChild(fragment)
   </script>
   ```

2. 少用table布局，table布局每次有单元格布局改变，都会进行整个tabel回流重绘；

3. 把DOM 离线后修改，例如先把 DOM 给 `display:none` (有一次 Reflow)，然后修改100次，再把它显示出来；

4. 频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video` 标签，浏览器会自动将该节点变为图层；



## 三、JS性能优化

### （1）使用事件委托



### （2）使用防抖和节流



### （3）尽量不要使用JS动画，使用CSS动画替代；

[css3动画](https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fcss3%2Fcss3-animations.html)和[canvas动画](https://juejin.cn/post/7008811592733655077)都比JS动画性能好



### （4）使用多线程，开启webWorker

复杂的计算开启webWorker进行计算，避免页面假死



### （5）计算结果缓存



## 四、图片优化

### （1）雪碧图

借助减少http请求次数来进行优化



### （2）图片懒加载

在图片即将进入可视区域的时候进行加载

#### 判断图片进入可视区域：

##### 1、方法一

使用`clientHeight+scroolTop > offsetTop`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>图片加载优化</title>
  </head>

  <body>
    <div style="background-color: green; width: 100vw; height: 8000px"></div>
    <div
      id="yellow"
      style="background-color: yellow; width: 100vw; height: 800px"
    ></div>

    <script>
      document.addEventListener("scroll", () => {
        const clientH = document.documentElement.clientHeight; //获取屏幕可视区域的高度
        const scrollT = document.documentElement.scrollTop; //获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离
        const offsetTop = document.getElementById("yellow").offsetTop; //获取元素相对于文档顶部的高度
        if (clientH + scrollT > offsetTop) {
          console.log("进入可视区域啦！！");
        }
      });
    </script>
  </body>
</html>
```



##### 2、方法二

下滑过程中bound.top会越来越小

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图片加载优化</title>
</head>

<body>
    <div style="background-color: green;width:100vw;height:8000px">
    </div>
    <div id="yellow" style="background-color: yellow;width:100vw;height:800px">
    </div>

    <script>
        document.addEventListener('scroll', () => {
            var bound = document.getElementById('yellow').getBoundingClientRect(); ////获取元素的大小及位置
            var clientHeight = window.innerHeight;
            if (bound.top <= clientHeight) {
                console.log('进入可视区域啦')
            }
        })
    </script>
</body>
</html>
```



### （3）使用CSS3代替图片

有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好



### （4）图片压缩

1. 使用网站进行压缩；
2. 通过webpack插件`iamge-webpack-loader`实现压缩；



### （5）使用webp格式

webp是一种新的图片文件格式，提供了有损压缩和无损压缩两种方式，相同质量下，webp的体积比png和jpg更小；



## 五、webpack优化

### （1）缩小loader的匹配范围

优化loader配置，使用`include、exclude`控制loader处理范围；

```js
include: path.resolve(__dirname, "./src")
```



### （2）resolve.module

配置webpack去哪个目录下寻找第三方模块，提高查找效率；

```js
module.exports = {
  resolve: {
    modules: [path.resolve(__dirname, "./node_modules")],
  },
};
```



### （3）使用extensions补充后缀

`resolve.extensions`在导⼊语句没带⽂件后缀时，webpack会⾃动带上后缀后，去尝试查找⽂件是否存在，越精细查找效率越高；



### （4）抽离CSS

使用`mini-css-extract-plugin`插件从JS中提取CSS但单独文件，提高加载效率；

```js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
 {
 test: /\.less$/,
 use: [
 // "style-loader", // 不再需要style-loader，⽤MiniCssExtractPlugin.loader代替
  MiniCssExtractPlugin.loader,
  "css-loader", // 编译css
  "postcss-loader",
  "less-loader" // 编译less
 ]
 },
plugins: [
  new MiniCssExtractPlugin({
   filename: "css/[name]_[contenthash:6].css",
   chunkFilename: "[id].css"
  })
 ]
```



### （5）代码压缩

#### 1、JS压缩

在生产模式下会自动压缩JS代码，使用的是`erser-webpack-plugin`插件

```js
module.exports = {
  // ...
  optimization: {
    minimize: true,
    minimizer: [new TerserPlugin({})],
  },
};
```



#### 2、CSS代码压缩

使用插件`css-minimizer-webpack-plugin`

```js
module.exports = {
  // ...
  optimization: {
    minimize: true,
    minimizer: [new CssMinimizerPlugin({})],
  },
};
```



#### 3、HTML文件压缩

使用插件`htmlwebpackplugin`开启压缩

```js
module.exports = {
  ...
  plugin: [
    new HtmlwebpackPlugin({
      ...
      minify: {
        minifyCSS: false, // 是否压缩css
        collapseWhitespace: false, // 是否折叠空格
        removeComments: true, // 是否移除注释
      },
    }),
  ],
};
```



#### 4、文件大小压缩

对文件大小进行压缩，减少http传输过程中带宽造成的损耗，使用插件`compression-webpack-plugin`

```js
new ComepressionPlugin({
  test: /.(css|js)$/, // 哪些文件需要压缩
  threshold: 500, // 设置文件多大开始压缩
  minRatio: 0.7, // 至少压缩的比例
  algorithm: "gzip", // 采用的压缩算法
});

```



#### 5、图片压缩

图片体积较大，压缩较为重要

```js
module: {
  rules: [
    {
      test: /.(png|jpg|gif)$/,
      use: [
        {
          loader: "file-loader",
          options: {
            name: "[name]_[hash].[ext]",
            outputPath: "images/",
          },
        },
        {
          loader: "image-webpack-loader",
          options: {
            // 压缩 jpeg 的配置
            mozjpeg: {
              progressive: true,
              quality: 65,
            },
            // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭
            optipng: {
              enabled: false,
            },
            // 使用 imagemin-pngquant 压缩 png
            pngquant: {
              quality: "65-90",
              speed: 4,
            },
            // 压缩 gif 的配置
            gifsicle: {
              interlaced: false,
            },
            // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式
            webp: {
              quality: 75,
            },
          },
        },
      ],
    },
  ];
}
```



### （6）Tree Shaking

消除死代码，将代码中没用的部分删除掉；

```js
module.exports = {
  optimization: {
    usedExports,
  },
};
```

使用之后，没被用上的代码在`webpack`打包中会加入`unused harmony export mul`注释，用来告知 `Terser` 在优化时，可以删除掉这段代码



### （7）代码分离

将代码分离到不同的bundle中，控制资源加载优先级，避免首页加载资源过大；

```js
module.exports = {
    ...
    optimization:{
        splitChunks:{
            chunks:"all"
        }
    }
}
```

`splitChunks`主要属性有如下：

- Chunks，对同步代码还是异步代码进行处理
- minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分
- maxSize： 将大于maxSize的包，拆分为不小于minSize的包
- minChunks：被引入的次数，默认是1



## 六、Vue优化

v-for添加key

路由懒加载

第三方插件按需引入

合理使用computed缓存数据和wach

destroy时销毁绑定的事件和定时器（addEventListener添加的事件、setTimeout、setInterval、bus.$on绑定的监听事件等）

注意v-for和v-if的优先级（Vue2中先for后if，Vue3先if后for）



## 七、React优化

- map循环添加key

- 路由懒加载

- 第三方插件按需引入

- 合理使用pureComponent避免不必要的渲染

- 使用memo或者pureComponent避免不必要的渲染

- 合理使用useMome、mome、useCallback

  - useCallback 是针对**函数**进行“记忆”的，当它依赖项没有发生改变时，那么该函数的引用并不会随着组件的刷新而被重新赋值。当我们觉得一个函数不需要随着组件的更新而更新引用地址的时候，我们就可以使用 useCallback 去修饰它。

    React.memo 是对**组件**进行 “记忆”，当它接收的 props 没有发生改变的时候，那么它将返回上次渲染的结果，不会重新执行函数返回新的渲染结果。

    React.useMemo是针对 **值计算** 的一种“记忆“，当依赖项没有发生改变时，那么无需再去计算，直接使用之前的值，对于组件而言，这带来的一个好处就是，可以减少一些计算，避免一些多余的渲染。当我们遇到一些数据需要在组件内部进行计算的时候，可以考虑一下 React.useMemo

