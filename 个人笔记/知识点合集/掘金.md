## 8、CSS绘制三角形和1px线

### （2）绘制1px的线

现象：CSS设置1px，但是移动端上显示的却有些粗

物理像素：也叫设备像素，一个物理像素是显示器上最小的物理显示单元。在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值，IPhone6上有750*1334个物理像素颗粒。

逻辑像素：也称为设备独立像素或密度无关像素，由程序使用的虚拟像素，CSS像素，然后由系统转为物理像素。

设备像素比：定义了物理像素和设备独立像素的对应关系，计算方法：

```js
设备像素比dpr = 物理像素 / 逻辑像素(px)
```

​	由于手机屏幕分辨率越来越高，同样屏幕大小的一个手机，它的实际物理像素数更多了。因为不同的移动设备有不同的像素密度，所以写的1px在不同的移动设备上展示是不一样的。

**<font color=pink>实现1px物理像素的方法</font>**：

#### 2.1、利用box-shadow

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>实现1px的解决办法</title>
    <style>
      .box {
        width: 100px;
        height: 100px;
        margin: 50px auto;
        background-color: antiquewhite;
        box-shadow: 0px 1px 0px 0px rgba(0, 0, 0, 1);
      }
    </style>
  </head>
  <body>
    <div class="box"></div>
  </body>
</html>

```



#### 2.2、设置border-image

利用1px宽度图片做border图片

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>实现1px的解决办法</title>
    <style>
      .box {
        width: 100px;
        height: 100px;
        margin: 50px auto;
        background-color: antiquewhite;
      }
      .border-image-1px {
        border-bottom: 1px solid transparent;
        border-image: url(border.png) 30 stretch;
      }
    </style>
  </head>
  <body>
    <div class="box border-image-1px"></div>
  </body>
</html>

```



#### 2.3、使用background-image实现

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>实现1px的解决办法</title>
    <style>
      .box {
        width: 100px;
        height: 100px;
        margin: 50px auto;
        background-color: antiquewhite;
      }
      .background-image-1px {
        background: url(border.png) repeat-x left bottom;
        -webkit-background-size: 100% 1px;
        background-size: 100% 1px;
        background-color: antiquewhite;
      }
    </style>
  </head>
  <body>
    <div class="box background-image-1px"></div>
  </body>
</html>
```



#### 2.4、多背景渐变实现

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>实现1px的解决办法</title>
    <style>
      .background-gradient-1px {
        background: linear-gradient(#000, #000 100%, transparent 100%) left /
            1px 100% no-repeat,
          linear-gradient(#000, #000 100%, transparent 100%) right / 1px 100%
            no-repeat,
          linear-gradient(#000, #000 100%, transparent 100%) top / 100% 1px
            no-repeat,
          linear-gradient(#000, #000 100%, transparent 100%) bottom / 100% 1px
            no-repeat;
      }
      .box {
        width: 100px;
        height: 100px;
        margin: 50px auto;
        background-color: antiquewhite;
      }
    </style>
  </head>
  <body>
    <div class="box background-gradient-1px"></div>
  </body>
</html>
```



#### 2.5、viewport + rem实现

在viewport设置缩放，通过js去动态修改viewport的值。

```html
<meta
      name="viewport"
      id="WebViewport"
      content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
```

通过JS来动态修改viewport的值：

```js
var viewport = document.querySelector("meta[name=viewport]");
if (window.devicePixelRatio == 1) {
  viewport.setAttribute(
    "content",
    "width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
  );
}
if (window.devicePixelRatio == 2) {
  viewport.setAttribute(
    "content",
    "width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"
  );
}
if (window.devicePixelRatio == 3) {
  viewport.setAttribute(
    "content",
    "width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no"
  );
}
var docEl = document.documentElement;
var fontsize = 10 * (docEl.clientWidth / 320) + "px";
docEl.style.fontSize = fontsize;
```



#### 2.6、伪类 + transfrom实现

​	先把原先元素的`border`去掉，然后利用`:before`或者`:after`重做border，边框宽度设置为1px，并且transform的scale缩小一半，原先的元素相对定位，新做的border绝对定位。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
          name="viewport"
          id="WebViewport"
          content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
          />
    <title>实现1px的解决办法</title>
    <style>
      .scale-1px {
        position: relative;
        border: none;
      }
      .scale-1px:after {
        content: "";
        position: absolute;
        bottom: 0;
        background: #000;
        width: 100%;
        height: 1px;
        -webkit-transform: scaleY(0.5);
        transform: scaleY(0.5);
        -webkit-transform-origin: 0 0;
        transform-origin: 0 0;
      }
    </style>
  </head>
  <body>
    <div class="scale-1px"></div>
    <script>
      if (window.devicePixelRatio && devicePixelRatio >= 2) {
        document.querySelector("ul").className = "scale-1px";
      }
    </script>
  </body>
</html>
```



## 9、外边距重叠问题

​	外边距重叠就是`margin-collapse`，相邻的两个盒子的外边可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距。

- 两个相邻的外边距是正数时，折叠结果就是较大值；
- 相邻外边距是负数时，折叠结果是绝对值较大值；
- 一正一负，结果是相加的和；



## 10、CSS选择器

### （1）常见选择器

- id选择器（"#content"）
- 类选择器（".content"）
- 标签选择器（"div"、"p"）
- 子选择器（"ul>li"）
- 后代选择器（"li a"）
- 通配符选择器（"*"）
- 伪类选择器（"a:hover"）



### （2）可继承样式

- font-size
- font-family
- color



### （3）不可继承样式

- border
- padding
- margin
- width
- height



## 11、CSS优化

1. 多个CSS可合并，尽量减少http请求；
2. 属性值为0时，不加单位；
3. 将CSS文件放在页面最上面；
4. 避免使用后代选择器和过度约束；
5. 使用紧凑的语法；
6. 避免不必要的重复；
7. 使用语义化命名，便于维护；
8. 尽量减少`!important`使用；
9. 精简规则，尽可能合并不同类型的重复规则；
10. 遵守盒子模型规则；





## 12、CSS3新特性

1. css3边框——圆角效果 border-radius
2. css3边框——边框阴影 box-shadow
3. css3边框——边框图片 border-image
4. css3颜色——颜色之RGBA
5. css3颜色——渐变色彩gradient
   1. liner-gradient线性渐变
   2. radial-gradient径向渐变
   3. conic-gradient圆锥渐变
6. CSS3文字与字体——文本的阴影 text-shadow
7. CSS3文字与字体——@font-face 字体
8. CSS3变形–旋转 rotate()
9. CSS3变形–缩放 scale()
10. CSS3多列布局——Columns
11. CSS3多列布局——column-width 列宽
12. CSS3多列布局——column-count 列数
13. CSS3 列间距——column-gap
14. CSS3 动画——animation
15. CSS3 盒子模型——box-sizing
16. CSS3 伸缩布局(弹性盒布局)——Flexbox
17. 媒体查询`@media`



## 13、响应式设计

响应式网站设计是一个网站能够兼容多个设备，而不是为每一个设备终端做特定版本。

- 原理：基本原理是通过媒体查询（`@media`）查询检测不同设备屏幕尺寸做处理。

- 兼容性：页面头部必须有`meta`声明的`viewport`

  ```html
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-sacale=1.0, user-scalable=no" />
  ```



## 14、水平垂直居中

### （1）flex布局

```css
.father {
  display: flex;
  justify-content: center;
  align-items: center;
}
```



### （2）绝对定位+margin

```css
.father {
    position: relative;
}
.son {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    margin: auto;
}
```



### （3）绝对定位+transform

```css
.father {
    position: relative;
}
.son {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```



## 15、flex:1展开

- flex-grow:1 ：对应元素增长系数；
- flex-shrink:1 ：对应元素收缩规则；
- flex-basis:0% ：对应元素在主轴上的大小；



# 三、JS

## 1、JS数据类型和存储

Javascript一种有8种数据：

1. 基本数据类型：`undefined、Null、Bollean、Number、String、Symbol和BigInt`。
2. 引用数据类型：`Object`（本质上是一组无序的名值对组成的）。包含`function、Array、Date`等。

- 原始数据类型：直接存储在栈（stack）中，占据空间小，大小固定，属于被频繁使用的数据，所以在栈中存储；
- 引用数据类型：同时在栈和堆中存储，占据空间大，大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。



## 2、类型判断方法

​	在JS中可以使用`Object.prototype.toString.call()`方法判断数据类型。

```js
var cache = Object.prototype.toString；
console.log(a.call(2));	// [object Number]
console.log(a.call(true)); // [object Boolean]
console.log(a.call("str")); // [object String]
console.log(a.call([])); // [object Array]
console.log(a.call(function () {})); // [object Function]
console.log(a.call({})); // [object Object]
console.log(a.call(undefined)); // [object Undefined]
console.log(a.call(null)); // [object Null]
```



## 3、null和undefined的区别

`undefined`和`null`都是基本数据类型，且这两种基本数据类型分别都只有一个值。

**undefined代表的含义是未定义**，**null代表的含义是空对象**。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。

其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

 undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false



## 4、{}和[]的valueOf和toString的结果

```markdown
{}的valueOf结果为{}，toString()结果为"[Object, Object]"；
[]的valueOf结果为[]，toString()的结果为""
```



## 5、JS的作用域和作用域链

### （1）作用域

作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找；



### （2）作用域链

​	每个执行上下文的变量环境中，都包含一个**外部引用**，用来指向外部的执行上下文。当函数中使用外部变量时，查找这个变量的“链条”称为**作用域链**。

​	**作用域链是由词法作用域决定的**，词法作用域是**由代码中函数声明位置决定的**，是静态作用域，在代码编译阶段就决定好的，和函数由谁调用没关系。



## 6、this、call、apply和bind的理解

![image-20230412204341418](https://raw.githubusercontent.com/Rainchen0504/picture/master/202304122043725.png)



## 7、原型、原型链

### （1）原型

​	js中使用构造函数新建对象，每个构造函数内部都有一个`prototype`属性，这个属性是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。

​	当使用构造函数新建一个对象后，这个对象内部包含一个指针，这个指针指向构造函数的`prototype`属性对应的值。在ES5中这个指针被称为对象的原型，使用`Object.getPrototypeOf()`方法可以获取对象的原型（浏览器实现了`_proto_`属性用来访问对象的原型，但是该方法不规范，不建议使用）。



### （2）原型链

​	当访问一个对象的属性时，如果该属性不在这个对象内部，会去原型对象里找这个属性，这个原型对象也会有自己的原型，就这么一直找下去，这就是原型链的概念。原型链的尽头一般都是`Object.prototype`这也解释了为什么新建的对象能使用`toString()`方法的原因。

​	JS对象是通过引用传递的，创建的每个新对象实体中并没有属于自己的原型副本。当修改原型时，所有与之相关的对象都会继承发生变化。



### （3）实现继承

使用class类，用extends关键字进行继承，或直接改变对象的`__proto__`指向；

```js
class Car {
  constructor(brand) {
    this.brand = brand;
  }
  showBrand() {
    console.log("the brand of car :>> ", this.brand);
  }
}

class ElectricCar extends Car {
  constructor(brand, duration) {
    super(brand);
    this.duration = duration;
  }
  showDuration() {
    console.log(`duration of this ${this.brand} ElectricCar :>> `, this.duration);
  }
}

ElectricCar.prototype.showOriginator = function (originator) {
  console.log(`originator of this ElectricCar :>> `, originator);
};

const tesla = new ElectricCar("tesla", "600km");
tesla.showBrand(); // the brand of car :>>  tesla
tesla.showDuration(); // duration of this tesla ElectricCar :>>  600km
console.log("tesla instanceof Car :>> ", tesla instanceof Car); // tesla instanceof Car :>>  true
console.log("tesla instanceof ElectricCar :>> ", tesla instanceof ElectricCar); // tesla instanceof ElectricCar :>>  true
console.log("tesla.__proto__ :>> ", tesla.__proto__); // tesla.__proto__ :>>  Car {}
console.log("ElectricCar.prototype === tesla.__proto__  :>> ", ElectricCar.prototype === tesla.__proto__); // ElectricCar.prototype === tesla.__proto__  :>>  true
tesla.showOriginator("Mask"); // originator of this  ElectricCar :>>  Mask

const bydCar = {
  brand: "比亚迪",
  duration: "666km",
};
bydCar.__proto__ = ElectricCar.prototype;

bydCar.showBrand(); //the brand of car :>>  比亚迪
bydCar.showDuration(); // duration of this 比亚迪 ElectricCar :>>  666km

```



## 8、闭包

​	内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束，但是内部函数引用外部函数的变量依然保存在内存中，这些变量的集合称为**闭包**。

- 优点：
  - 内部变量是私有的，可以做到隔离作用域，保持数据不被污染；
- 缺点：
  - 垃圾回收机制无法清理到内部变量，会导致内存泄漏；



## 9、事件模型

事件是用户操作网页时发生的交互动作或者网页本身的一些操作，**现代浏览器一共有<font color=yellow>三种事件模型</font>**。

### （1）DEM0级模型

​	这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。

### （2）IE事件模型

​	在该事件模型中，一次事件共有两个过程，**事件处理阶段**，和**事件冒泡阶段**。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。

### （3）DOM2级事件模型

​	在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。



## 10、js数组方法

```js
push //向尾部添加，修改原数组
shift	//从头部删除，修改原数组
unshift	//向头部添加，修改原数组
pop	//从尾部删除，修改原数组
splice	//删除、添加元素，修改原数组
concat	//合并数组
join	//将数组所有元素合并放入字符串
toString	//数组转字符串
reverse	//反转数组
slice	//返回指定元素，不修改原数组
sort	//数组排序，从小到大
indexOf	//返回第一次出现索引
lastIndexOf	//返回最后一次索引
forEach	//循环遍历数组
map	//遍历数组返回新数组
```



## 11、js字符串方法

```js
chartAt	// 返回指定位置的字符串
chartCodeAt	//返回指定位置字符的unicode编码
concat	//拼接字符串
indexOf	//检索字符串
match	//找到正则匹配的字符串
repalce	//替换正则匹配的字符串
search	//检索正则匹配的值
slice	//提取字符串片段，返回新字符串，不修改原字符串
split	//拆分字符串为数组
toLocaleLowerCase	//把字符串转换为小写
toLocalUpperCase	//把字符串转换为大写
toLowerCase	//把字符串转换为小写
toUpperCase	//把字符串转换为大写
substr	//从起始索引提取指定数量字符
substring	//提取两个索引之间的字符
```



## 12、JS延时加载方式

JS加载、解析和执行会阻塞页面，因此希望js延时加载提高页面渲染速度。

1. 将js脚本放在文档底部，使得js脚本尽可能在最后执行；
2. 给js脚本添加defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样；
3. 给js脚本添加async属性，这个属性会让脚本异步加载，不会阻塞页面解析过程，但是当脚本加载完成后立即执行js，如果文档没有解析完成的话同样会遇到阻塞。多个async属性脚本是不可预测的，一般不会按照代码顺序执行；
4. 动态创建DOM标签的方式，对文档的加载事件进行监听，当文档加载完成后再动态创建script标签引入js脚本；



## 13、JS模块规范

目前成熟的有四种模块加载方案：

1. CommonJS：通过`require`引入模块，通过`module.exports`定义模块的输出接口。这种模块加载方案是服务端解决方案，以<font color=pink>**同步的方式引入模块**</font>，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。
2. AMD：采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖该模块的语句都定义在一个回调函数中，等加载完成后再执行回调函数，require.js实现了AMD规范。
3. CMD：和AMD都是为了解决异步模块加载问题；
4. ESModule：使用`import`和`export`形式导入导出模块



## 14、AMD和CMD规范区别

### （1）模块定义时对依赖的处理不同

1. AMD推崇依赖前置，在定义模块时候就要声明其依赖的模块；
2. CMD推崇就近依赖，只有在用到某个模块时再去`require`；



### （2）对依赖模块执行时机不同

AMD和CMD对于模块的加载方式都是**异步加载**

1. AMD是预加载，在依赖模块加载完成后就直接执行依赖模块，依赖模块执行顺序和书写顺序不一定一致；
2. CMD是懒加载，在依赖模块加载完成后并不执行只进行下载，等到所有依赖模块都加载好后进入回调函数逻辑，遇到`require`语句才执行对应的模块，执行顺序和书写顺序一致；

```js
// CMD
define(function(require, exports, module) {
  var a = require("./a");
  a.doSomething();
  //省略逻辑
  var b = require("./b");
  b.doSomething();
  // ...
})

// AMD
define(["./a", "./b"], function(a,b) {
  // 依赖必须一开始就写好
  a.doSomething()
  //省略逻辑
  b.doSomething()
  // ...
})
```



## 15、ESModule和CommonJS和AMD、CMD差异

### （1）语法上

CommonJS使用的是`module.exports = {}`导出一个模块对象，`require('pathName')`引入模块对象；

ESModule使用的是`export`导出指定数据，`import`引入具体数据；



### （2）值类型上

CommonJS输出的是值的拷贝，输出后模块内部变化不会影响这个值；

ESModule输出的是值的引用，且不会缓存值；



### （3）加载时机上

CommonJS模块是运行时加载，就是对象，输入时先加载整个模块生成一个对象，然后从对象上读取；

ESModule是编译时加载，不是对象，可以通过`export`命令显式指定输出代码，可以指定加载某个输出值；



## 16、JS事件循环机制

​	JS是单线程的（JS引擎在执行代码的时候只有一个主线程，每次只能干一件事），同时还是非阻塞运行的（执行异步任务的时候，会先挂起相应的任务，待异步返回结果载执行回调）。

​	在js代码执行时，会将对象存在堆中，在栈中存放一些基础类型变量和对象的指针。对于普通函数就是正常的入栈出栈即可，涉及到异步任务的时候，js执行会将对应的任务放到事件队列中（微任务队列、宏任务队列）。

常见宏任务：queueMicrotask、Promise和MutationObserve；

常见微任务：ajax、setTimeout、setInterval、IO操作、UI操作、postMessage等；

### 执行机制

1. 先执行主线程执行栈中的宏任务；
2. 执行过程中如果遇到微任务，进入“事件列表”并注册函数，完成后移入到微任务队列中；
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务；
4. 主线程会不断获取任务队列中的任务、执行任务、再获取、再执行任务也就是事件循环；



## 17、内存泄漏

### （1）导致内存泄漏的原因

1. 意外的全局变量

   js对未声明的变量会在全局对象上创建该变量的引用，在窗口关闭和刷新之前都不会被释放；

   ```js
   //都会绑定在window对象上
   function fn(){
     a = "message"
   }
   fn()
   
   function fn(){
     this.a = "message"
   }
   fn()
   ```

2. 闭包

   闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中。如果在使用结束后没有将局部变量清除，就可能导致内存泄露。

   ```js
   function fn(){
     var a = "hello";
     return function(){
       console.log(a)
     }
   }
   ```

3. 没有清理的DOM引用

   虽然在某个地方删除了元素，但是对象中还存在对DOM的引用。

   ```js
   // 在对象中引用DOM
   var elements = {
     btn: document.getElementById('btn'),
   }
   function doSomeThing() {
     elements.btn.click()
   }
   
   function removeBtn() {
     // 将body中的btn移除, 也就是移除 DOM树中的btn
     document.body.removeChild(document.getElementById('btn'))
     // 但是此时全局变量elements还是保留了对btn的引用, btn还是存在于内存中,不能被回收
   }
   ```

4. 遗忘的定时器或回调

   定时器中存在dom的引用，即使dom被删除，定时还存在，内存中还会保留这个dom



### （2）避免内存泄漏

1. 避免创建全局变量；
2. 是用严格模式，在JS文件头部或函数顶部加`use strict`；
3. 将事件处理函数定义在外部，解除闭包；
4. 手动删除失效DOM元素的引用；
5. 手动删除失效的定时器和dom，移除不必要的事件监听；



## 18、ES6新特性

- 块级作用域let、const
- 类class
- 基本数据类型Symbol
- 箭头函数
- 模板字符串
- 对象解构赋值
- 对象字面量
- promise
- 函数默认参数
- 拓展运算符
- 模块化import/export
- Set和Map
- Proxy
- 生成器和迭代器



## 19、箭头函数

​	不会创建自身的this，只会从上一级继承this，箭头函数this在定义时候就已经确认了，之后不会再改变，由词法作用域决定。

```js
// ES5
var getCurrentDate = function (){
  return new Date()
}

// ES6
const getCurrentDate = () => new Date()
```

箭头函数没有自己的`this`和`arguments`，也不能作为构造函数，使用`new`操作符调用。



## 20、高阶函数

高阶函数是将函数作为参数或返回值的函数。

```js
function higherOrderFunction (param,callback) {
  return callback(param)
}
```



## 21、call、apply和bind函数

### （1）call函数

- 先处理边界条件；
- 将调用函数挂载到this指向的对象的fn属性上；
- 执行this指向的对象上的fn函数，并传入参数返回结果；

写法一：

```js
// 调用函数
function foo(name, age) {
  console.log(this, name, age)
}

Function.prototype.ycCall = function (thisArg, ...otherArg) {
  // 边界条件判断，this绑定的对象不存在就指向window
  thisArg = thisArg === null || thisArg === undefined ? window : Object(thisArg);
  // 给要绑定的对象创建fn属性，值为调用ycCall的函数
  Object.defineProperty(thisArg, 'fn', {
    enumerable: false,
    configurable: true,
    value: this
  });
  // 执行fn属性（即调用ycCall的函数并返回结果），就将this指向绑定到要绑定的对象上了
  thisArg.fn(...otherArg)
  // 删除fn属性
  delete thisArg.fn
}
foo.ycCall({name:"zhang"}, "man", 25)
```

写法二：

```js
Function.prototype.my_call = function (context, ...args) {
  //obj不存在指向window
  if(!context || context === null) {
    context = window;
  }
  // 创造唯一的key值，作为构造的context内部方法名
  let fn = Symbol();
  // this指向调用call的函数
  context[fn] = this;
  // 执行函数并返回结果，相当于把自身作为传入的context的方法进行调用
  return context[fn](...args);
}
// 测试
var value = 2;
var obj1 = {
  value: 1,
};
function bar(name, age) {
  var myObj = {
    name: name,
    age: age,
    value: this.value,
  };
  console.log(this.value, myObj);
}
bar.mu_call(null); //打印 2 {name: undefined, age: undefined, value: 2}
bar.mu_call(obj1, 'tom', '110'); // 打印 1 {name: "tom", age: "110", value: 1}
```



### （2）apply函数

apply参数为**数组**，call参数为**参数序列**

```js
function foo(age){
  console.log(this, age)
}
Function.prototype.ycapply = function (thisArg, otherArg) {
  thisArg = thisArg === null || thisArg === undefined ? window : Object(thisArg);
  Object.defineProperty(thisArg, 'fn', {
    enumerable: false,
    configurable: true,
    value: this
  });
  thisArg.fn(...otherArg);
  delete thisArg.fn
}
foo.ycapply({name:"zhang"}, [25])
```



### （3）bind函数

bind函数返回this改变后的函数

```js
function foo(name,age){
  console.log(this, name, age)
}
Function.prototype.ycbind = function (thisArg, ...otherArg) {
  thisArg = thisArg === null || thisArg === undefined ? window : Object(thisArg);
  Object.defineProperty(thisArg, 'fn', {
    enumerable: false,
    configurable: true,
    writable: false,
    value: this
  })
  return (...newArgs) => {
    var allArg = [...otherArg, ...newArgs];
    thisArg.fn(...allArg)
  }
}
var newFoo = foo.ycbind("zhang", "chen", 26)
```



## 22、函数柯里化

​	只传递给函数一部分参数调用它返回一个函数去处理剩余参数。将多个参数的一个函数转换成一些列使用一个参数的函数的技术。

```js
// 普通函数
function add (x,y,z) {
  return x + y + z
}
// 柯里化函数
function addCurry(x) {
  return function(y) {
    return function(z) {
      return x + y + z
    }
  }
}
```

### （1）自动化柯里化函数

写法一：

```js
function foo(x, y, z) {
  console.log(x + y + z);
}

// 自动柯里化函数
function autoCurry (fn) {
  // fn是传入的函数，长度是函数参数个数
  function curryied (...args) {
    // args是调用时的参数
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    } else {
      function curryied2 (...args) {
        return curryied.apply(this, [...args, ...args2])
      }
      return curryied2
    }
  }
  return curryied
}

let curryFoo = autoCurry(foo);
console.log(curryFoo(10)(20)(30)) //60
console.log(curryadd(10, 20, 30)) //60
```

写法二：

```js
function curry(fn, args) {
  // 获取函数参数长度
  let length = fn.length;
  args = args || [];
  return function() {
    let subArgs = args.slice(0);
    // 拼接现有参数
    for (let i = 0; i < arguments.length; i++) {
      subArgs.push(arguments[i])
    }
    // 判断参数的长度是否已经满足函数所需参数的长度
    if (subArgs.length >= length) {
      // 如果满足，执行函数
      return fn.apply(this, subArgs);
    } else {
      // 如果不满足，递归返回科里化的函数，等待参数的传入
      return curry.call(this, fn, subArgs);
    }
  }
}
```



## 23、实现一个new操作符

new一个对象的四步：

1. 创建一个空对象；
2. 将空对象的`__proto__`指向构造函数的原型对象`prototype`；
3. 将构造函数的this指向创建出的新对象；
4. 执行构造函数给对象绑定属性；

```js
let obj = new Object();
obj._proto_ = Function.prototype;
let res = Function.call(obj);
if(typeof res === 'object') {
  return res
} else {
  return obj
}
```



## 24、Promise

​	`Promise`就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。

### （1）特征

1. promise有三个状态：pending待定，fulfilled完成，rejected失败，默认状态是pending。
2. promise有一个value保存成功状态的值，有一个reason保存失败状态的值，可以是undefined/thenable/promise。
3. promise只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变。
4. promise 必须有一个then方法，then接收两个参数，分别是promise成功的回调onFulfilled, 和promise失败的回调onRejected。
5. 如果then中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败的回调onRejected。



### （2）手写

```js
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class CustomPromise {
  constructor(executor) {
    try {
      executor(this.resolve, this.reject);
    } catch (error) {
      // 如果有错误，就直接执行 reject
      this.reject(error);
    }
  }
  // resolve和reject为什么要用箭头函数？
  // 如果直接调用的话，普通函数this指向的是window或者undefined
  // 用箭头函数就可以让this指向当前实例对象
  resolve = (value) => {
    // promise只能从pending到rejected, 或者从pending到fulfilled
    if (this.status == PENDING) {
      this.status = FULFILLED;
      this.value = value;

      // resolve里面将所有成功的回调拿出来执行
      if (this.onResolvedCallbacks.length) {
        this.onResolvedCallbacks.forEach((fn) => fn());
      }
    }
  };
  reject = (err) => {
    // promise只能从pending到rejected, 或者从pending到fulfilled
    if (this.status == PENDING) {
      this.status = REJECTED;
      this.reason = err;
      // reject里面将所有失败的回调拿出来执行
      if (this.onFulfilledCallbacks.length) {
        this.onFulfilledCallbacks.forEach((fn) => fn());
      }
    }
  };
  // 存储成功回调函数
  onResolvedCallbacks = [];
  // 存储失败回调函数
  onFulfilledCallbacks = [];

  status = PENDING;
  // 成功之后的值
  value = undefined;
  // 失败之后的值
  reason = undefined;

  then(onFulfilled, onRejected) {
    // 如果不传，就使用默认函数,确保是函数类型
    onFulfilled =
      typeof onFulfilled === "function" ? onFulfilled : (value) => value;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (reason) => {
            throw reason;
          };

    const thenCustomPromise = new CustomPromise((resolve, reject) => {
      const resolveCustomPromise = (callBack, value) => {
        try {
          const x = callBack(value);
          // 如果相等了，说明return的是自己，抛出类型错误并返回
          if (resolveCustomPromise === x) {
            return reject(new TypeError("类型错误"));
          }
          // 判断x是不是 CustomPromise 实例对象
          if (x instanceof CustomPromise) {
            // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected
            // x.then(value => resolve(value), error => reject(reason))
            // 简化之后
            x.then(resolve, reject);
          } else {
            // 普通值
            resolve(x);
          }
        } catch (error) {
          reject(error);
        }
      };
      // 需要判断状态，根据状态选择处理回调函数
      if (this.status == FULFILLED) {
        resolveCustomPromise(onFulfilled, this.value);
      } else if (this.status == REJECTED) {
        resolveCustomPromise(onRejected, this.reason);
      } else if (this.status == PENDING) {
        // 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行
        this.onResolvedCallbacks.push(() =>
          resolveCustomPromise(onFulfilled, this.value)
        );
        this.onFulfilledCallbacks.push(() =>
          resolveCustomPromise(onRejected, this.reason)
        );
      }
    });
    return thenCustomPromise;
  }
  catch(onFulfilled) {
    return this.then(null, onFulfilled);
  }
  finally(callback) {
    return this.then(
      (value) => CustomPromise.resolve(callback()).then(() => value),
      (reason) => CustomPromise.resolve(callback()).then(() => reason)
    );
  }
  //静态的resolve方法
  static resolve(value) {
    if (value instanceof CustomPromise) return value;
    return new CustomPromise((resolve) => resolve(value));
  }
  //静态的reject方法
  static reject(reason) {
    return new CustomPromise((resolve, reject) => reject(reason));
  }
  //静态的all方法
  static all(values) {
    // 用来记录Promise成功的次数
    let resolveCount = 0,
      // 用来保存Promise成功的结果
      resolveDataList = [];
    return new CustomPromise((resolve, reject) => {
      function addPromise(key, value) {
        resolveDataList[key] = value;
        resolveCount++;
        if (resolveCount === values.length) {
          resolve(resolveDataList);
        }
      }

      for (let i = 0; i < values.length; i++) {
        let item = values[i];
        if (item instanceof CustomPromise) {
          // 参数为Promise
          item.then(
            (value) => addPromise(i, value),
            (error) => reject(error)
          );
        } else {
          // 参数为普通值
          addPromise(i, item);
        }
      }
    });
  }
  //静态race方法
  static race(values) {
    return new CustomPromise((resolve, reject) => {
      for (const p of values) {
        p.then(resolve, reject);
      }
    });
  }
  //静态allSettled方法
  static allSettled(values) {
    return new Promise((resolve, reject) => {
      let resolveDataList = [],
        resolveCount = 0;
      const addPromise = (status, value, i) => {
        resolveDataList[i] = {
          status,
          value,
        };
        resolveCount++;
        if (resolveCount === values.length) {
          resolve(resolveDataList);
        }
      };
      values.forEach((value, i) => {
        if (value instanceof CustomPromise) {
          value.then(
            (res) => {
              addPromise("fulfilled", res, i);
            },
            (err) => {
              addPromise("rejected", err, i);
            }
          );
        } else {
          addPromise("fulfilled", value, i);
        }
      });
    });
  }
  //静态any方法
  static any(values) {
    return new CustomPromise((resolve, reject) => {
      let rejectCount = 0;
      values.forEach((value) => {
        value.then(
          (val) => resolve(val),
          (err) => {
            rejectCount++;
            if (rejectCount === value.length) {
              reject("All promises were rejected");
            }
          }
        );
      });
    });
  }
}
```

https://juejin.cn/post/7194257890893365308



## 25、async和await

### （1）特征

async---**声明了一个异步函数**

1. 自动将常规函数转换成promise，返回值也是一个promise对象；
2. 只有async函数内部的异步操作完成，才会执行then方法指定的回调函数；
3. 异步函数内部可以使用await；

await---**暂停异步的功能执行**

1. 放置在promise调用之前，await强制其它代码等待，直到promise完成返回结果；
2. 只能与promise一起使用，不适用与回调；
3. 只能在async函数内部使用；



### （2）手写

```js
const getFetch = (nums) => {
  new Promise((resolve) => {
    setTimeout(() => {
      resolve(nums + 1)
    }, 1000)
  })
}

function* gen(){
  let res1 = yield getFetch(1)
  let res2 = yield getFetch(res1)
  let res3 = yield getFetch(res2)
  return res3
}

// 接受一个生成器Generator函数作为参数
function myAsync (gen) {
  // 返回一个函数
  return function () {
    // 返回一个promise
    return new Promise ((resolve,reject) => {
      // 执行Generator函数
      let g = gen()
      const next = (context) => {
        let res
        try {
          res = g.next(context)
        } catch (error) {
          reject (error)
        }
        if(res.done) {
          // 表明完成
          resolve(res.value)
        } else {
          // 继续执行next函数
          return Promise.resolve(res.value).then(val => next(val), err => next(err))
        }
      }
      next();
    })
  } 
}
```

https://juejin.cn/post/7195358576364224568



## 26、instanceof优缺点

用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

### （1）优点

能够区分`Array`、`Object`和`Function`，适合用于判断自定义的类实例对象；

### （2）缺点

`Number`、`Boolean`，`String`基本数据类型不能判断

### （3）手写

1. 传入参数为左侧实例和右侧构造函数；
2. 处理边界条件，基本类型返回false；
3. 分别获取传入参数的原型；
4. 判断左侧的原型是否取到了null，如果是null返回false；如果两侧原型相等，返回true，否则继续获取左侧原型的原型；

```js
// 传入参数左侧为实例，右侧是构造函数
function my_instanceof(L, R) {
  // 处理边界条件,检测实例是否为原始类型
  const baseTypes = ['string','number','boolean','symbol','undefined'];
  if(baseTypes.includes(typeof L) || L === null) return false
  
  // 分别传入参数的原型
  let Lp = L.getPrototypeOf(); // __proto__方法存在浏览器兼容性问题
  let Rp = R.prototype; //函数才有的prototype属性
  
  // 判断原型
  while(true) {
    if(Lp === null) return false;
    if(Lp=== Rp) return true;
    Lp = Lp.getPropertyOf();
  }
}
```



## 27、节流与防抖

### （1）防抖

事件被触发n秒后再执行回调函数，如果n秒过程中被触发，则重新开始计时；

```js
function debounce (fn, delay) {
  let timer = null;
  return function () {
    if (timer != null) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn()
    },delay)
  }
}
```



### （2）节流

单位时间n秒内，保证事件只调用一次；

```js
function throttle (fn, delay, ...args) {
  let pre = Date.now();
  return function () {
    // 函数可能会有入参
    let context = this;
    let now = Date.now();
    if (now - pre >= wait) {
      //将执行函数的this指向当前作用域
      fn.apply(context, args)
      pre = Date.now()
    }
  }
}
```



## 28、JS小数运算

常见现象

```js
0.1 + 0.2 === 0.3 //结果为false，真正的结果为0.30000000000000004
```



### （1）计算机中数字存储方式

计算机中数字无论是定点数还是浮点数都是以**二进制的方式**进行存储的。

如果以8位二进制来存储数字：

1. 对于整数来说，十进制的35会被存储为：00100011，表示2^5 + 2^1 + 2^0；
2. 对于纯小数来说，十进制的0.37会被存储为：0.011，表示1/2^2 + 1/2^3；
3. 对于0.1这样的数值采用二进制无法整除，因为存储空间有限计算机会舍弃后面的数值，最后得到一个近似值。

JS中采用的IEEE 754的双精度标准也是一样的道理在存储空间有限的情况下，当出现这种无法整除的小数的时候就会取一个近似值，在JS中如果这个近似值足够近似，那么js就会认为他就是那个值。

```js
console.log(0.1000000000000001) 
// 0.1000000000000001 (中间14个0，会打印除本身)
console.log(0.10000000000000001) 
// 0.1 (中间15个0，js会认为两个值足够近似，所以输出0.1)
```

<font color=pink>JS中的小数在计算机中存储的基本都是近似值；所以在实际开发中应该尽量避免小数的计算。</font>



### （2）解决方法

1. 将浮点数转换为整数计算；
2. 十进制数转换成二进制（`Number.toString(进制)`）；
3. 其他进制转换成十进制（`parseInt(目标数值,进制)`）;



## 29、迭代器和生成器函数

任意一个对象实现了遵守迭代器协议的`[Symbol.iterator]`方法，那么该对象就可以调用`[Symbol.iterator]`返回一个遍历器对象。生成器函数就是遍历器生成函数，因此可以把`generator`赋值给对象的`[Symbol.iterator]`属性，从而使该对象具有迭代器接口。

```js
class ClassRoom {
  constructor(address, name, students) {
    this.address = address;
    this.name = name;
    this.students = students;
  }
  entry(student) {
    this.students.push(student);
  }
  *[Symbol.iterator]() {
    yield* this.students;
  }
  // [Symbol.iterator](){
  //   let index = 0;
  //   return {
  //     next: () => {
  //       if(index < this.students.length){
  //         return {done:false, value:this.students[index++]}
  //       } else {
  //         return {done:true, value:undefined}
  //       }
  //     },
  //     return: () => {
  //       return {done:true, value:undefined}
  //     }
  //   }
  // }
}
const classOne = new ClassRoom("7-101", "teach-one-room", ["rose", "jack", "lily", "james"]);
for (const stu of classOne) {
  console.log("stu :>> ", stu);
  // stu :>>  rose
  // stu :>>  jack
  // stu :>>  lily
  // stu :>>  james
  // if (stu === "lily") return;
}
```



## 30、typeof和instanceof

typeof和instanceof都是用来判断变量的类型的，区别在于：

1. typeof判断所有变量的类型，返回值包括`number、string、boolean、function、object、undefined`六种类型；
2. typeof对于丰富的对象实例，只能返回`object`，导致有时候得不到真实的数据类型；
3. instanceof用来判断对象，代码形式`object instanceof constructor`判断**实例对象**是否是**构造函数**的实例，返回的值是布尔值；
4. instanceof可以对不同的实例对象进行判断，判断方法是根据对象的原型链依次向下查询，如果**<font color=pink>构造函数的原型对象属性存在于实例对象的原型链上</font>**，值为true；

# 四、Vue

## 1、虚拟DOM

​	通过`createElement`方法创建 `VNode` 的过程，每个 `VNode` 有 `children`，`children` 每个元素也是一个`VNode`，这样就形成了一个虚拟树结构，用于描述真实的`DOM`树结构。

​	Vue 通过建立一个**虚拟 DOM** 来追踪自己要如何改变真实 DOM。它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。这样的节点被描述为“虚拟节点 (virtual node)”，也常简写它为“**VNode**”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。

​	采用虚拟dom让开发者写的代码在性能上得到保障，无限接近命令式代码的性能。通常情况下，纯JS层面的操作远比DOM操作快，虚拟DOM就是JS用来模拟DOM结构，通过Diff算法计算出最小的变更，通过对应的渲染器，渲染到页面上。为跨平台开发者提供了极大的便利，开发者写同一套代码通过不同的渲染规则，可以生成不同平台的代码。



## 2、Vue2和VuE3的区别和优化

### （1）响应式系统

- V2 中响应式系统的核心是 `Object.defineProperty`，劫持整个对象，然后进行深度遍历所有属性，给每个属性添加`getter`和`setter`，实现响应式；

- V3 中使用`Proxy`对象重写响应式系统，可以监听动态新增的属性，监听删除的属性，监听数组的索引和`length`属性；

- 实现原理：

  - 通过 Proxy（代理）拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除；

  - 通过 Reflect（反射）对源对象的属性进行操作；

    ```js
    new Proxy(data, {
      // 拦截读取属性
      get (target, prop) {
        return Reflect.get( target, prop )
      }
      // 拦截设置属性值或添加新属性
      set (target, prop, value) {
      	return Reflect.set( target, prop, value )
    	}
      // 拦截删除属性
    	deleteProperty (target, prop) {
        return Reflect.deleteProperty( target, prop )
      }
    })
    ```



### （2）书写方面

1. 提供setup的方式配合组合式API，可以建立组合逻辑、创建响应式数据、创建通用函数、注册生命周期钩子函数等；
2. 支持多个根节点；
3. 声明周期写法变化，`on`开头；



### （3）diff算法方面

- vue2中使用的是双端diff算法，同时比较新旧两组节点的两个端点的算法（比头、比尾、头比尾、尾比头）
- vue3中使用的是快速diff算法，借鉴了文本diff算法的预处理思路，先处理新旧两组节点中相同的前置节点和后置节点。当前置节点和后置节点全部处理完毕后，如果无法通过简单的挂载新节点或者卸载已经不存在的节点来更新，则根据节点间的索引关系，构造出一个最长递增子序列，最长递增子序列所指向的节点即为不需要移动的节点；



### （4）编译阶段

1. Vue2.x：通过标记静态节点，优化 diff 算法的过程；
2. Vue3.x：
   1. 静态标记，vue3 中标记和提升所有的静态节点，diff 的时候只要对比动态节点内容；
   2. 跟节点限制，template 中不需要唯一的根节点，可以直接放文本或者同级标签；
   3. 静态提升，所有静态的节点都被提升到`render`方法之外，只会在应用启动的时候被创建一次，之后使用只需要应用提取的静态节点，随着每次的渲染被不停的复用；
   4. `patch flag`，在动态标签末尾加上相应的标记，只能带 patchFlag 的节点才被认为是动态的元素，会被追踪属性的修改,能快速的找到动态节点,而不用逐个逐层遍历，提高了虚拟 dom diff 的性能；
   5. 缓存事件处理函数`cacheHandler`，避免每次触发都要重新生成全新的`function`去更新之前的函数；



### （5）源码体积

- 相比 Vue2，Vue3 整体体积变小了，移除了一些不常用的 API
- tree-shanking
  - 任何一个函数，如 ref、reactive、computed 等，仅在用到的时候打包；
  - 通过编译阶段的静态分析，找到没有引入的模块并打上标记，将这些模块都摇掉；



### （6）其他

- 对`typescript`语法支持提升
- ssr渲染性能提升
- 打包体积优化，包体减小
- v-if和v-for优先级不痛，vue2是先for后if，vue3是先if后for，性能得到提升



## 3、Vue3 新组件

### （1）Fragment

- 在 Vue2 中：组件必须有一个根标签；
- 在 Vue3 中：组件可以没有根标签，内部会将多个标签包含在一个 Fragment 虚拟元素中；
- 好处：减少标签层级，减少内存占用；

### （2）Teleport

将**<font color=yellow>组件 html 结构</font>**移动到指定位置的技术

```vue
<teleport to="移动位置">
	<div v-if="isShow" class="mask">
    <div class="dialog">
      <h3>我是一个弹窗</h3>
      <button @click="isShow = false">关闭弹窗</button>
    </div>
  </div>
</teleport>
```

### （3）Suspense

- 等待异步组件时渲染一些额外内容，让应用有更好的用户体验；

- 使用步骤

  - 异步引入组件

    ```js
    import { defineAsyncComponent } from "vue";
    const Child = defineAsyncComponent(() => import("./components/Child.vue"));
    ```

  - 使用 Suspense 包裹组件，并配置好 default 和 fallback

    ```vue
    <template>
       
      <div class="app">
             
        <h3>我是App组件</h3>
             
        <Suspense>
                   
          <template v-slot:default>
                          <Child />          
          </template>
                   
          <template v-slot:fallback>
                         
            <h3>加载中.....</h3>
                     
          </template>
               
        </Suspense>
         
      </div>
    </template>
    ```



## 4、生命周期

### （1）vue2 的生命周期

- beforeCreate 创建前，数据观测和初始化事件还未开始，不能访问到 data、computed、watch、methods 上的方法和数据；
- created 创建后，实例创建完成，渲染得节点还未挂载到 DOM，所以不能访问到 `$el` 属性；
- beforeMount 挂载前，相关的 render 函数首次被调用，把 data 里面的数据和模板生成 html，但是还没挂载到页面；
- mounted 挂载后，用上面编译好的 html 内容替换 el 属性指向的 DOM 对象，完成模板中的 html 渲染到 html 页面中；
- beforeUpdate 更新前，响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染；
- updated 更新后，数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用，调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作；
- beforeDestroy 销毁前，实例销毁之前调用，实例仍然完全可用，`this` 仍能获取到实例。
- destroyed 销毁后，实例销毁后调用，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁；

### （2）vue3 的生命周期

Vue3.0 中可以继续使用 Vue2.x 中的生命周期钩子，但是卸载阶段两个生命周期被修改。

- `beforeCreate ===> setup()`
- `created ===> setup()`
- `beforeMount ===> onBeforeMount`
- `mounted ===> onMounted`
- `beforeUpdate ===> onBeforeUpdate`
- `updated ===> onUpdated`
- `beforeUnmount ===> onBeforeUnmount`
- `unmounted ===> onUnmounted`



## 5、Composition API 和 React Hook 区别

React Hook 是基于 useState 的调用顺序来确定下一个 render 渲染时间状态从哪个 useState 开始，所以有以下几个限制：

- 不在循环中、条件、调用嵌套函数 Hook
- 必须确保它总是在 React Top level 调用函数 Hook
- 使用效果、使用备忘录 依赖关系必须手动确定

Composition API 是基于 Vue 的响应系统：

- 在设置函数中，一个组件实例只调用一次设置，而 React Hook 每次重新渲染时，都需要调用 Hook，给 React 带来的 GC 比 Vue 更大的压力，性能也相对 Vue 对我来说也比较慢
- Compositon API 不必担心调用的顺序，它也可以在循环中、条件、在嵌套函数中使用
- 响应式系统自动实现依赖关系收集，而且组件的性能优化是由 Vue 内部完成的，而 React Hook 的依赖关系需要手动传递，并且依赖关系的顺序必须得到保证，让路 useEffect、useMemo 等等，否则组件性能会因为依赖关系不正确而下降。



## 6、Composition Api 与 Options Api 区别

### （1）Options Api

选项式 API，以`vue`为后缀的文件，通过定义`methods`，`computed`，`watch`，`data`等属性与方法，共同处理页面逻辑；

### （2）Composition Api

组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）

### （3）对比

- 在逻辑组织和逻辑复用方面，`Composition API`是优于`Options API`；
- 因为`Composition API`几乎是函数，会有更好的类型推断；
- `Composition API`对 `tree-shaking` 友好，代码也更容易压缩；
- `Composition API`中见不到`this`的使用，减少了`this`指向不明的情况；



## 7、SPA 单页面应用

单页 Web 应用（single page web application，SPA），就是只有一张 Web 页面的应用，是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序。我们开发的`Vue`项目大多是借助个官方的`CLI`脚手架，快速搭建项目，直接通过`new Vue`构建一个实例，并将`el:'#app'`挂载参数传入，最后通过`npm run build`的方式打包后生成一个`index.html`，称这种只有一个`HTML`的页面为单页面应用。 当然，`vue`也可以像`jq`一样引入，作为多页面应用的基础框架。



## 8、首屏加载优化

1. 减少入口文件体积；
2. 静态资源本地缓存；
3. UI 组件按需引入；
4. 图片资源压缩；
5. 组件重复打包；
6. 开启 GZip 压缩；
7. 使用 SSR 渲染；



## 9、Vue 项目优化

1. v-if 和 v-show
   1. 频繁切换使用 v-show
   2. 首屏渲染使用 v-if，为 false 不进行渲染
2. v-for 的 key
   1. 列表变化时，循环时使用唯一不变的`key`
   2. 列表只进行一次渲染时，`key`可以采用循环的`index`
3. 侦听器和计算属性
   1. 侦听器`watch`用于监听数据变化时触发其他行为
   2. 多使用`computed`计算属性，计算属性返回新计算而来的属性，存在缓存，如果依赖的数据未发生变化，不会触发重新计算
4. 合理使用生命周期
   1. 在`destroyed`阶段进行绑定事件或者定时器的销毁
   2. 使用动态组件的时候通过`keep-alive`包裹进行缓存处理，相关的操作可以在`actived`阶段激活
5. 数据响应式处理
   1. 不需要响应式处理的数据可以通过`Object.freeze`处理，或者直接通过`this.xxx = xxx`的方式进行定义；
   2. 需要响应式处理的属性可以通过`this.$set`的方式处理；
6. 路由加载方式
   1. 页面组件可以使用异步加载的方式
7. 插件引入
   1. 第三方插件使用按需引入的方式
8. 减少代码量
   1. 采用`mixin`的方式抽离公共方式；
   2. 抽离公共组件，抽离公共方法；
   3. 抽离公共 css
9. 编译方式
   1. 如果需要模板编译器，可以采用`vue.esm.js`完全版的 vue 包；
   2. 如果不需要模板编译器，可以使用运行时版本`vue.runtime.esm.js`，相比完整版体积小大约 30%；
10. 渲染方式
    1. 服务端渲染，如果需要 SEO 优化的网站采用服务端渲染；
    2. 前端渲染，返回 html、js、css 资源文件渲染；
11. 字体图标
    1. 减少图片使用，尽量使用字体图标；



## 10、vue 组件通信

### （1）组件通信方法

1. 父到子组件通过`props`；
2. 子到父组件使用`$emit`触发自定义事件；
3. 使用 ref 获取组件实例上的方法；
4. 事件总线`EventBus`；
5. 使用`$parent`或`$root`获取父或根组件实例上的方法；
6. 使用`$attrs`和`$listeners`获取父组件作用域绑定的属性和事件；
7. 使用`provide`和`inject`跨组件层级传递参数；
8. 使用 vuex 进行组件通信；



### （2）使用场景

父子关系传递数据使用`props`和`$emit`传递，可以使用`ref`;

兄弟组件数据传输可以使用事件总线`$bus`或`$parent`进行传递；

祖先与后代组件数据传递建议使用`provide`和`inject`；

复杂关系组件数据可以通过vuex存放共享变量；



## 11、Vue常见修饰符

### （1）表单修饰符

#### 1.1、`.lazy`

在默认情况下，`v-model`在每次`input`事件触发后将输入框的值与数据进行同步，可以添加`lazy`

#### 1.2、`.number`

如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符

#### 1.3、`.trim`

如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符



### （2）事件修饰符

#### 2.1、`.stop`

阻止单击事件继续传播

#### 2.2、`.prevent`

阻止标签的默认行为

#### 2.3、`.capture`

事件先在有`.capture`修饰符的节点上触发，然后在其包裹的内部节点中触发

#### 2.4、`.self`

只当在 event.target 是当前元素自身时触发处理函数，即事件不是从内部元素触发的

#### 2.5、`.once`

当前事件只触发一次

#### 2.6、`.passive`

不阻止事件的默认行为，用于改善移动端设备的滚屏性能



## 12、$nextTick的作用

官方定义：

​	等待下一次DOM更新刷新的工具方法。 

可以理解为：

​	Vue更新DOM是异步执行的，当数据发生变化时，Vue会开启一个异步更新队列，视图会在等待队列所有数据变化完成之后再进行统一更新。这样保证组件无论发生多少状态改变，都仅执行一次更新。



## 13、理解双向绑定

数据层（Model）：应用的数据及业务逻辑

视图层（View）：应用的展示效果，各类UI组件

业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来，数据变化后更新视图，视图变化后更新数据。



### （1）vue2

通过数据劫持并结合发布者-订阅者模式的方式。使用`Object.defineProperty`劫持对象中所有属性的setter和getter，在数据变化时发布消息给订阅者，触发相应的监听回调来渲染视图。

1. 首先，在实例化的过程中，把一个普通JS对象传给Vue实例的data选项，Vue遍历此对象的所有属性，并使用`Object.defineProperty`把这些属性全部转为`getter/setter`；
2. Dep是一个依赖收集器，data下的每个属性都有一个唯一的Dep对象，在get中收集仅针对该属性的依赖，然后在set方法中触发所有收集的依赖；
3. 在Watcher中对表达式求值，从而触发数据的get。在求值之前将当前Watch实例设置到全局，使用pushTarget(this)方法；
4. 在get()中收集依赖，this.subs.push(sub),set的时候触发回调Dep.notify()；
5. Compile中首先将template或el编译成render函数，render函数返回一个虚拟DOM对象（将模板转为 render 函数的时候，实际是先生成的抽象语法树（AST），再将抽象语法树转成的 render 函数）；
6. 当 vm._render 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照Vue中 watcher.js 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍；
7. 如果还没有 prevVnode 说明是首次渲染，直接创建真实DOM。如果已经有了 prevVnode 说明不是首次渲染，那么就采用 patch 算法进行必要的DOM操作。这就是Vue更新DOM的逻辑；



### （2）vue3

使用Proxy代理对象

```js
// WeakMap常用于存储只有当key所引用的对象存在时（没有被回收）才有价值的消息，十分贴合双向绑定场景
const bucket = new WeakMap(); // 存储副作用函数

let activeEffect; // 用一个全局变量处理被注册的函数

const tempObj = {}; // 临时对象，用于操作

const data = { text: "hello world" }; // 响应数据源

// 用于清除依赖
function cleanup(effectFn) {
  for (let i = 0; i < effectFn.deps.length; i++) {
    const deps = effectFn.deps[i];
    deps.delete(effectFn);
  }
  effectFn.deps.length = 0;
}

// 处理依赖函数
function effect(fn) {
  const effectFn = () => {
    cleanup(effectFn);
    activeEffect = effectFn;
    fn();
  };
  effectFn.deps = [];
  effectFn();
}

// 在get时拦截函数调用track函数追踪变化
function track(target, key) {
  if (!activeEffect) return; //
  let depsMap = bucket.get(target);
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()));
  }
  let deps = depsMap.get(key);
  if (!deps) {
    depsMap.set(key, (deps = new Set()));
  }

  deps.add(activeEffect);

  activeEffect.deps.push(deps);
}

// 在set拦截函数内调用trigger来触发变化
function trigger(target, key) {
  const depsMap = bucket.get(target);
  if (!depsMap) return;
  const effects = depsMap.get(key);
  const effectsToRun = new Set(effects);
  effectsToRun.forEach(effectFn => effectFn());
  // effects && effects.forEach(fn => fn());
}

const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    if (!activeEffect) return; //
    console.log("get -> key", key);
    track(target, key);
    return target[key];
  },

  // 拦截设置操作
  set(target, key, newValue) {
    console.log("set -> key: newValue", key, newValue);
    target[key] = newValue;
    trigger(target, key);
  },
});

effect(() => {
  tempObj.text = obj.text;
  console.log("tempObj.text :>> ", tempObj.text);
});

setTimeout(() => {
  obj.text = "hi vue3";
}, 1000);
```



### （3）手动实现过程

1. 实现一个监听器Observer，侦听劫持所有的属性，如果属性发生变化，就告诉订阅者Watcher是否更新。
2. 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3. 实现一个订阅器Dep，因为订阅者有很多个，所以需要使用Dep专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理。
4. 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据模板数据初始化相应的订阅器。

<img src="https://raw.githubusercontent.com/Rainchen0504/picture/master/202304041502032.png" alt="在这里插入图片描述" style="zoom:67%;" />



## 14、v-if和v-show

相同点：都能控制元素在页面上是否显示。

区别：

​	v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除；

​	v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；

​	v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染；

性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；



## 15、keep-alive

缓存的内置组件，使用场景为路由组件和动态组件。

*   `activated`表示进入组件的生命周期，`deactivated`表示离开组件的生命周期
*   `include`表示匹配到的才缓存，`exclude`表示匹配到的都不缓存
*   `max`表示最多可以缓存多少组件







## 17、data为什么是函数而不是对象

vue实例化的时候定义

​	使用函数形式是因为函数返回的对象内存地址并不相同，如果是对象组件之间可能会造成覆盖修改。

​	vue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染



## 18、Vue2的初始化过程

new Vue进入Vue的构造函数中`src/core/instance/index.js`文件；

`this._init(options)`

然后从`Mixin`增加的原型方法看，`initMixin(Vue)`调用的是Vue增加原型方法`_init`

```js
// src/core/instance/init.js

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
     var vm = this; 创建vm, 
     ...
     // 合并options 到 vm.$options
     vm.$options = mergeOptions(  
       resolveConstructorOptions(vm.constructor), 
       options || {},  
       vm 
     );
  }
  initLifecycle(vm); //初始生命周期
  initEvents(vm); //初始化事件
  initRender(vm); //初始render函数
  callHook(vm, 'beforeCreate'); //执行 beforeCreate生命周期钩子
  ...
  initState(vm);  //初始化data，props，methods computed，watch 
  ...
  callHook(vm, 'created'); //执行created生命周期函数
  if (vm.$options.el) {
    vm.$mount(vm.$options.el);
  }
}
```

### new Vue过程流程：

1. 合并配置属性
2. 初始化生命周期
3. 初始化事件
4. 初始化渲染函数
5. 调用`beforeCrearte`钩子函数
6. init injections and reactivity（这个阶段属性都已注入绑定，而且被 `$watch` 变成reactivity，但是 `$el` 还是没有生成，也就是DOM没有生成）
7. 初始化state状态（初始化data、props、computed、wtacher）
8. 调用created钩子函数

初始化最后，检测如果有el属性，则调用`vm.$mount`方法挂载`vm`，挂载的目标就是把模板渲染成最终的DOM。



## 19、Vue3的初始化过程

`createApp() => mount() => render() => patch() => processComponent() => mountComponent()`



## 20、Vue中做SSR渲染

SSR相比SPA的优势：

- 更好的SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；
- 更快的内容到达时间，特别是对于缓慢的网络情况或运行缓慢的设备；

Vue.js是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

服务器渲染的`Vue.js`应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。

- Vue SSR是一个在SPA上进行改良的服务端渲染；
- 通过Vue SSR渲染的页面，需要在客户端激活才能实现交互；
- Vue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA；

使用ssr不存在单例模式，每次用户请求都会创建一个新的vue实例 实现ssr需要实现服务端首屏渲染和客户端激活 服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取 首屏异步获取数据，在服务端预渲染的时候就应该已经完成 切换组件通过mixin混入，在beforeMount钩子完成数据获。



## 21、Vue中的Diff算法

diff算法是一种通过同层的树节点比较的高效算法

diff整体策略为：**深度优先，同层比较**；

- 当数据发生变化时，订阅者`watcher`就会调用`patch`给真实的`DOM`打补丁；
- 通过`isSameVnode`进行判断，相同则调用`patchVnode`方法
  - 找到对应的真实dom，简称el；
  - 如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点；
  - 如果oldVnode有子节点而Vnode没有，则删除子节点；
  - 如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el
  - 如果两者都有子节点，则执行`updateChildren`函数进行比较子节点;
    - 设置新旧VNode的头部指针；
      - 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用`patchVnode`进行`patch`重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作；



## 22、从0到1构建Vue项目

- 框架：脚手架创建项目
- 请求：封装axios，设置axios请求的配置；
- 登录：登录注册系统；
- 路由：路由管理界面；
- 数据：使用pinia或vuex全局数据管理；
- 权限：权限管理系统；
- 埋点：埋点系统；
- 错误：错误页面封装；
- 入口：前端资源当静态资源，或者服务端模板拉取；
- SEO：建议使用SSR方案；
- 组件：基础组件/业务组件；
- 样式：样式预处理，公共样式抽取；
- 方法：公共方法抽离；



## 23、Vue3中的ref、toRef、toRefs

ref：接收一个内部值，生成对应的内部数据挂载在ref对象的value属性上该对象可以用于模版和reactive。使用ref是为了解决值类型在setup、computed、合成函数等情况下的响应式丢失问题；

toRef：为响应式对象的一个属性创建对应的ref，且该方式创建的ref与源属性保持同步；

toRefs：将响应式对象转换为普通对象，对象的每个属性都是对应的ref，两者保持同步，实用toRefs进行解构



## 24、Computed和Watch的区别

### （1）使用场景

- computed适用于一个数据受多个数据影响使用；
- watch适用于一个数据影响多个数据使用；



### （2）缓存

- computed属性默认返回缓存的值，只有依赖的数据发生变化的时候，才会重新计算返回新数据；
- watch不支持缓存，一旦数据发生变化就触发响应操作；



### （3）支持异步

- computed不支持异步；
- watch支持异步



## 25、vue-R-router路由

### （1）全局前置守卫

```js
rotuer.beforeEach((to, from, next) => {
	// to要进入的目标页面
  // from当前导航离开的页面
  return false // 返回内容1:布尔值表示是否取消导航
  return {name: 'login'} // 返回内容2:返回到对应name的路由页面
  next({name: 'login'}) // 返回内容3:进入到对应页面
  next() // 放行
})
```



### （2）全局解析守卫

```js
router.beforeResolve(to => {
    if(to.meta.canCopy) {
        return false // 也可取消导航
    }
})
```



### （3）全局后置钩子

```js
router.afterEach((to, from) => {
    logInfo(to.fullPath)
})
```



### （4）导航错误钩子

```js
router.onError(error => {
    logError(error)
})
```



### （5）路由独享守卫

beforeEnter可以传入单个函数，也可传入多个函数

```js
function dealParams(to) {
    // ...
}
function dealPermission(to) {
    // ...
}

const routes = [
    {
        path: '/home',
        component: Home,
        beforeEnter: (to, from) => {
            return false // 取消导航
        },
        // beforeEnter: [dealParams, dealPermission]
    }
]
```



### （6）组件内守卫

```js
const Home = {
    template: `...`,
    beforeRouteEnter(to, from) {
        // 此时组件实例还未被创建，不能获取this
    },
    beforeRouteUpdate(to, from) {
        // 当前路由改变，但是组件被复用的时候调用，此时组件已挂载好
    },
    beforeRouteLeave(to, from) {
        // 导航离开渲染组件的对应路由时调用
    }
}
```



### （7）完整路由导航流程

1. 导航被触发；
2. 在失活的组件中调用`beforeRouteLeave`组件的后置守卫；
3. 调用全局的`beforeEach`前置守卫;
4. 在重用的组件中调用`beforeRouteUpdate`更新守卫；
5. 在路由配置中调用对应路由的`beforeEnter`独享守卫；
6. 解析异步路由组件；
7. 在被激活的组件中调用`beforeRouteEnter`组件的前置守卫；
8. 调用全局`beforeResolve`解析守卫；
9. 导航被确认；
10. 调用全局`afterEach`后置守卫；
11. 触发DOM更新；
12. 调用`beforeRouteEnter`守卫中传给`next`的回调函数，创建好的组件实例会作为回调函数的参数传入；



# 五、React

## 1、类组件和函数组件生命周期

### （1）类组件

#### 1.1、初始化阶段

- 类组件会执行constructor（其只会在初始化阶段执行一次，使用super(props)确保props传递成功，同时做一些初始化操作，如声明state，绑定this等）。
- 如果存在getDerivedStateFromProps就执行getDerivedStateFromProps（该函数传入两个参数（nextProps，prevState），其作用是：代替componentWillMount和componentWillReceiveProps;在组件初始化或更新时，将props映射到state；其返回值会与state合并，可作为shouldComponentUpdate的第二个参数newState，用于判断是否需要渲染）。
- 不存在的话componentWillMount（由于存在隐匿风险已经废弃，不建议使用）将会被执行，到此mountClassComponent函数咨询完成。
- 之后会执行render（创建React.element元素的过程）渲染函数，形成children，接下来React会调用reconcileChildren方法深度调和children。react调和完所有的fiber节点，就会进入到commit阶段。
- 然后执行componentDidMount（其执行时机和componentDidUpdate一样，只是一个是初始化阶段，一个是更新阶段，此时DOM已经挂载，可以进行DOM操作，同时可以向服务端请求数据，渲染视图）。

```js
constructor ->
getDerivedStateFromProps -> 
componentWillMount -> 
render -> 
componentDidMount
```



#### 1.2、更新阶段

- 类组件会判断是否存在getDerivedStateFromProps，不存在会执行componentWillReceiveProps，存在就执行getDerivedStateFromProps（返回的值用于合成新的state）。
- 之后执行shouldComponentUpdate（用于性能优化），传入新的props、state、context，根据其返回值来决定是否执行render函数。
- 接下来执行componentWillUpdate，到这里updateClassInstance方法执行完毕。
- 接下来进入render函数，得到最新的React Element元素，然后继续调和子节点。 之后进入commit阶段。
- 执行getSnapshotBeforeUpdate（会返回一个DOM修改前的快照，作为传递给compontDidUpdate的第三个参数，该参数不限于DOM的信息，可以时DOM计算出的产物）。
- 然后会执行compontDidUpdate（此时dom已经修改完成，可以进行dom操作；不能再这个函数里执行setState操作，否则会导致无限循环）。

```js
componentWillReciveProps(props改变)/getDrivedStateFromProp ->
shouldComponentUpdate ->
componentWillUpdate ->
render ->
getSnapshotBeforeUpdate ->
componentDidUpdate
```



#### 1.3、销毁阶段

- 类组件执行componentWillUnmount（清除一些定时器、事件监听器）



### （2）函数组件

#### 1.1、useEffect

- 第一个参数cb，返回的destory作为下一次cb执行之前调用，用于清楚上一次cb产生的副作用；
- 第二个参数是依赖项，为一个数组，依赖改变，执行上一次cb返回的destory，和执行新的effect的cb。
-  useEffect的执行，React采用的异步调用的逻辑，对于每一个effect的cb，React会将其放入到事件队列中，等主线程完成，DOM更新，js执行完毕，视图绘制完成，才执行，effect的回调不会阻塞浏览器的视图绘制。

```js
useEffect(() => {
    return destory
}, dep)
```



#### 1.2、useLayoutEffect

不同于useEffect的是，采用了同步执行，它是在DOM更新前，浏览器绘制之前执行，适合在这个时候修改DOM，这样浏览器只会绘制一次。如果将修改DOM操作放在useEffect中，会导致浏览器的重绘和回流。故useLayoutEffect的cb会阻塞浏览器绘制。

```js
useLayoutEffect(() => {
    // deal Dom
}, dep)
```



# 六、浏览器

## 1、从URL到页面展示

1. 进行URL解析，判断输入的是否是合法的URL或是搜索关键字；
2. 从浏览器缓存中查找请求文件，如果存在就拦截请求，返回缓存资源，请求结束；
3. 进行DNS解析，将域名映射为对应的IP地址；
4. 建立TCP连接，确定目标服务器IP地址后，经历三次握手确认客户端与服务器的接收与发送能力，建立TCP连接；
5. 发送HTTP请求，建立TCP连接后，在此基础上进行通信，浏览器发送http请求到目标服务器；
6. 响应请求，当服务器接收到浏览器请求后，会进行逻辑操作，处理完成后返回一个HTTP响应信息；
7. 断开TCP连接，分析是否进行重定向，重定向重新执行请求流程；
8. 浏览器接收到服务器响应资源后，对资源进行解析；
9. 渲染进程解析HTML，构建DOM树；
10. 渲染进程解析CSS，生成CSS规则树；
11. 合并DOM树和CSS规则，生成布局树；
12. 进行样式计算，绑定布局样式信息，确定节点宽高，只包含可见元素；
13. 对布局树分层，创建分层树；
14. 对每个图层生成绘制列表，交给合成线程
15. 合成线程将图层分成图块，在光栅化线程池中转换为位图；
16. 合成线程发送绘制指令给浏览器进程；
17. 浏览器进程根据指令显示在显示器上，移除旧数据更新页面；



## 2、H5中本地存储

### （1）概念

H5中`Web storage`存储方式有两种：`sessionStorage`和`localStorage`。

- sessionStorage用于本地存储一个会话中的数据，当会话结束后就销毁；
- localStorge用于持久化存储本地数据，除非用户主动删除数据，否则数据永远不过期；
- cookie是网站为了标识用户身份而存储在用户本地终端上的数据；



### （2）相互之间的区别

#### 2.1、从浏览器和服务器间传递区分

`cookie`始终在同源的`http`请求中携带，在浏览器和服务器之间来回传递；

`sessionStorage`和`localStorage`不会把数据发送给服务器，仅在本地保存；



#### 2.2、从大小区分

`cookie`数据不能超过4K，只适合保存很小的数据；

`sessionStorage`和`localStorage`比`cookie`大得多，可以达到5M或更大；



#### 2.3、从数据有效期区分

`sessionStorage`会话关闭后会立刻关闭，可持续性不久；

`localStorage`持续性存储；

`cookie`只在设置的过期时间内一致有效，即使关闭窗口或浏览器；



#### 2.4、从作用域区分

`sessionStorage`不在不同的浏览器窗口共享，即使是同一个页面；

`localStorage`和`cookie`可以在所有的同源窗口中共享；



## 3、常见浏览器内核

- `Trident`内核：IE最先开发或使用的， 360浏览器；
- `Webkit`内核：Google Chrome，Safari， 搜狗浏览器，360极速浏览器， 阿里云浏览器等；
- `Gecko`内核： Mozilla FireFox (火狐浏览器) ，K-Meleon浏览器；
- `Presto`内核：Opera浏览器；



## 4、强缓存和协商缓存

### （1）强缓存

浏览器在加载资源时，会根据本地缓存资源的headers中的信息（expires和cahe-control）判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。



### （2）协商缓存

当强缓存没有命中的时候，浏览器会发送请求到服务器，服务器会根据header中的部分信息（Etag和Last-Modifed属性）判断是否命中缓存，如果命中则返回304状态码，告诉浏览器使用本地缓存。



## 5、浏览器一个Tab

### （1）进程结构

Chrome浏览器至少包括四个：**1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程和多个插件进程**。

- 页面中有`iframe`的话`iframe`会单独在进程中；
- 有插件的话插件会开启进程；
- 多个页面属于同一站点，从a打开到b页面会共用一个渲染进程；



### （2）多进程单页面卡死的原因

举个例子：如果多个页面符合同一站点，这几个页面会被分配到一个渲染进程中，一旦一个页面崩溃了，会导致同一个站点的其它页面也崩溃，因为它们使用的是同一个渲染进程。



## 6、解决IE浏览器兼容问题

- 由`float`引起的双边距的问题，使用`display`解决；
- 由`float`引起的3像素问题，使用`display: inline -3px`;
- 使用正确的书写顺序`link visited hover active`，解决超链接`hover`点击失效问题；
- 对于`IE` 的`z-index`问题，通过给父元素增加`position: relative`解决；
- 使用`!important`解决`Min-height`最小高度问题；
- 使用`iframe`解决`select`在`IE6`下的覆盖问题；
- 使用`over: hidden`, `zoom: 0.08`, `line-height: 1px`解决定义1px左右的容器宽度问题；



## 7、V8垃圾回收机制

### （1）回收策略

垃圾回收分为**手动回收**和**自动回收**两种策略：

- C/C++使用手动回收策略，由代码控制分配内存和销毁内存；
- JS、Java、Python使用自动垃圾回收策略，产生的垃圾数据由垃圾回收器释放，不需要手动释放；



### （2）栈数据回收

​	调用栈中有一个记录当前执行状态的指针，指向调用栈中正在执行函数的执行上下文，函数执行完成后，销毁该函数执行上下文，指针移到下一个执行函数上下文。



### （3）堆数据回收

​	V8引擎的垃圾回收机制基于代际假说，有两个特点：第一个是大部分对象在内存中存在的时间很短，一经分配内存很快就变得不可访问；第二个是不死的对象会活的更久；

​	V8会把堆分为**新生代**和**老生代**两个区域，新生代存放<font color=pink>**生存时间短的对象**</font>，采用副垃圾回收器；老生代存放<font color=pink>**生存时间长的对象**</font>，采用主垃圾回收器；

#### 回收流程：

1. 第一步：标记空间中在使用的对象和可以进行垃圾回收的对象；
2. 第二步：回收垃圾占据的内存，即标记完成后统一清理内存中被标记对象；
3. 第三步：内存整理，回收对象后内存中出现大量不连续空间，需要进行合并整理；



#### 副垃圾回收器

​	新生代中使用`Scavenge`算法，把空间对半分为两个区域，一半是对象区域，一半是空闲区域。新加入对象会进入对象区域，当对象区域快写满时执行一次垃圾清理操作。

- 对对象区域垃圾做标记，把存活对象复制到空闲区域，排序整理消除内存碎片；
- 复制完成后，对象区域和空闲区域进行角色反转；
- 为了提升执行效率，新生区空间一般较小；
- 经过两次垃圾回收还活着的对象会晋升到老生区中；



#### 主垃圾回收器

​	主垃圾回收器采用**<font color=red>标记-清除</font>**算法，从根元素递归遍历，能达到的元素标记为活动对象，否则为垃圾数据。标记结束后清除垃圾，边清除边整理，减少内存碎片导致的内存分配问题。由于垃圾回收时会暂停应用逻辑，因此引入增量标记方法，将每次停顿分成多步。除了新生区晋升对象，一些大对象会直接分配到老生区，因此老生区对象占空间大，存活时间长。



## 8、跨域问题

同源策略指的是域名、协议、端口号相同。

由于浏览器同源策略（浏览器安全功能，它会阻止一个域与另一个域的内容进行交互，能有效防止XSS、CSRF攻击）的限制，非同源的请求会被限制。

解决跨域问题的方法：

1. 使用nginx反向代理
2. 使用script标签，jsonp方式
3. 使用图片标签
4. 设置CORS，跨域资源共享
5. 利用iframe实现
6. 使用WebSocket

# 七、性能优化

## 1、优化网站文件和资源

1. 文件合并（减少http请求）
2. 文件压缩（减少文件下载的体积）
3. 使用缓存（本地存储）
4. 使用cdn托管资源
5. 开启gzip压缩JS和CSS文件
6. 网站外链优化
7. meta标签优化，alt属性优化，heading标签优化



## 2、利用多个域名来存储网站资源会更有效

- 突破浏览器并发限制；
- 节约`cookie`宽带；
- 节约主域名的连接数，优化页面下响应速度；
- 防止不必要的安全问题；
- `CDN`缓存更加方便；



## 3、回流(重排)和重绘

### （1）回流/重排

当页面元素因为规模尺寸、布局、显示隐藏等改变时而需要重新构建，称为回流；回流一定会引发重绘

- 删除或增加可见DOM元素；
- 元素位置发生改变；
- 元素尺寸发生改变（边距、宽高）；
- 内容改变（图片大小、字体大小）；
- 浏览器窗口尺寸改变；
- 页面渲染初始化



### （2）重绘

当页面中的元素需要更新部分颜色、背景、外观属性而不会影响布局时，称为重绘；重绘不一定引起回流。

- box-shadow
- border-radius
- outline
- ......



### （3）优化减少性能消耗

1. 避免一条一条的修改DOM的样式;
2. 将动画的HTML脱离文档流，就不会造成回流；
3. 避免在大量元素上使用`:hover`；
4. 避免使用 table 布局；
5.  避免设置多层内联样式；
6. 避免在布局信息改变时查询布局信息；
7. 当需要对DOM元素进行一系列的操作时，可以先使元素脱离文档流，再对其进行一些列操作，然后再把元素带回文档中；



## 4、大数据请求优化

首先大量数据的接收，那么肯定是用异步的方式进行接收，对数据进行一个分片处理，可以拆分成一个个的小单元数据，通过自定义的属性进行关联。这样数据分片完成。

接下来渲染的话，由于是大量数据，如果是长列表的话，这里就可以使用虚拟列表（当前页面需要渲染的数据拿到进行渲染，然后对前面一段范围及后面一段范围，监听对应的滚动数据来切换需要渲染的数据，这样始终要渲染的就是三部分）。

当然还有别的渲染情况，比如echarts图标大量点位数据优化等。

# 八、打包

## 1、webpack文件哈希配置

​	webpack中有时需要使用hash来做静态资源实现增量更新方案之一，文件名的hash值可以有三种hash生成方式。一般是结合CDN缓存使用的，如果文件内容发生改变，对应哈希值也会改变，对应的HTML引用的URL也会改变，触发CDN服务器从源服务器上拉取对应数据，从而更新本地缓存。

### （1）hash

跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。

### （2）chunkhash

根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着采用chunkhash的方式生成hash值，只要不改动公共库的代码，就可以保证其hash值不会受影响。

### （3）contenthash

表示由文件内容产生的hash值，内容不同产生的contenthash值也不一样。在项目中通常做法是把项目中css都抽离出对应的css文件来加以引用



## 2、webpack构建流程

1. 初始化参数：解析webpack配置参数，合并`shell`传入的参数和`webpack.config.js`文件配置的参数，形成最终的配置结果；
2. 开始编译：用上一步得到的参数初始化`compiler`对象，注册所有配置的插件，监听构建生命周期的事件节点，执行对象的run方法执行编译；
3. 确定入口：读取配置的`entry`入口，开始解析文件构建AST语法树，递归找出依赖；
4. 编译模块：调用loader配置对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过编译处理；
5. 完成编译模块：通过loader编译完所有模块后，得到每个模块编译后的内容和相互依赖关系；
6. 输出资源：根据入口模块的依赖关系，组装成一个个包含多个模块的`Chunk`，再把每个`Chunk`转换成一个单独的文件加入到输出列表；
7. 输出完成：确定好输出内容后，根据配置确定输出的路径和文件名，写入到文件系统；



## 3、loader和plugin的区别

### （1）区别

- loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，包括编译、压缩等，最终打包输出到指定的文件；
- plugin存在于webpack整个生命周期中，赋予了webpack各种灵活的功能，例如打包优化、资源管理、环境变量注入等；

### （2）执行时机

- loader在打包文件之前执行；
- plugins在整个编译周期都起作用；

### （3）总结

- loader实质上是一个转换器，将A文件编译成B文件，操作的是文件，单纯的文件转换过程；
- Webpack生命周期会广播出很多时间，plugin可以监听这些事件，并修改输出的结果；



## 4、编写loader

- 本质是一个函数
- 不能是箭头函数，要用到上下文的this
- 接收一个参数，参数是文件源代码
- 函数中有异步操作通过`this.callback`返回，返回值为`string`或者`Buffer`

```js
// 导出一个函数，参数为文件源代码
module.exports = function(source) {
  const content = doSomeThing(source);
  // 如果loader配置了options对象，那么this.query将指向options
 	const options = this.query;
  // this.callback参数：
  // 1.error：Error｜null，当loader出错时向外抛出一个error；
  // 2.content：String｜Buffer，经过loader编译后需要导出的内容；
  // 3.sourceMap：为方便调试生成的编译后内容的 source map
  // 4.ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程
  this.callback(null, content); // 异步
  return content; // 同步
}
```

使用这个loader：

```js
{
  test:/\.js$/,
  use:path.resolve(__dirname, './loader/newLoader.js')
}
```



## 5、编写plugin

- 必须要写`apply`方法，`webpack`会通过`apply`方法启动插件
- class中的`apply`不能写成箭头函数
- 异步的事件需要在插件处理完任务时调用回调函数通知 `Webpack` 进入下一个流程，不然会卡住
- webpack编译会创建两个核心对象：
  - compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子
  - compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建

```js
class MyPlugin {
  apply(compiler) {
    // compilation打包构建流程的上下文
    compiler.hooks.emit.tap('MyPlugin', (compilation) => {      
      // do something...
    })
  }
}
module.exports = MyPlugin
```

使用这个plugin：

```js
plugin:[
  new MyPlugin()
]
```



## 6、提高webpack构建速度

1. 优化loader配置
2. 合理使用`resolve.extensions`，解析文件自动添加扩展名后缀，提高查找速度；
3. 优化`resolve.modules`，说明第三方模块存放的位置，减少搜索步骤；
4. 优化`resolve.alias`，配置路径别名，提高查找速度；
5. 使用`cache-loader`持久化存储依赖提高构建性能；
6. 使用`DLLPlugin`插件，将公共代码单独打包，避免重复打包；
7. 使用`terser`插件多进程并行提高构建速度；
8. 打包生成`sourceMap`时越详细速度越慢；



## 7、webpack热更新

1. 通过express启动本地服务器；
2. 服务端和浏览器使用Websocket建立长连接；
3. Websocket监听本地资源变化；
4. 当资源发生变化时会生成两个文件.json（manifest文件）和.js文件（update chunk），产生新的hash值和更新的资源；
5. 客户端长连接接收到这两个文件hash值和上次进行比较，一致读取内存，不一致通过ajax和jsonp向服务端获取更新文件的内容；
6. 使用内存文件系统替换有修改的内容实现局部刷新；



## 8、常见loader

1. style-loader：将CSS添加到DOM的内联样式标签style里
2. css-loader：允许将CSS文件通过require方式引入，并返回CSS代码
3. less-loader：处理less转换为CSS文件
4. sass-loader：处理sass转换为CSS文件
5. postcss-loader：用postcss预处理CSS，转换单位、补全前缀等
6. file-loader：分发文件到output目录并返回相对路径
7. url-loader：和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url
8. html-minify-loader：压缩HTML
9. babel-loader：用babel来转换ES6文件到ES



## 9、常见Plugin

1. CleanWebpackPlugin：用于自动删除一遍出口文件夹，然后重新创建，避免每次打包都要手动删除一次
2. HtmlWebpackPlugin：打包出口生成HTML文件，用于服务器访问
3. DefinePlugin：允许在编译时配置的全局常量
4. CopyWebpackPlugin：将单个文件或整个目录复制到构建目录
5. AggressiveSplittingPlugin：将原来的chunk分成更小的chunk
6. CommonChunkPlugin：提取chunks之间共享的通用模块
7. DllPlugin：分离打包，极大减少构建时间



# 九、Git

### （1）基本操作

```shell
git init 初始化仓库，默认为 main 分支
git add . 提交全部文件修改到缓存区
git add <具体某个文件路径+全名> 提交某些文件到缓存区
git diff 查看当前代码 add后，会 add 哪些内容
git diff --staged查看现在 commit 提交后，会提交哪些内容
git status 查看当前分支状态
git pull <远程仓库名> <远程分支名> 拉取远程仓库的分支与本地当前分支合并
git commit -m "<注释>" 提交代码到本地仓库，并写提交注释
git commit -v 提交时显示所有diff信息
```



### （2）提交规则

```shell
feat: 新特性，添加功能
fix: 修改 bug
refactor: 代码重构
docs: 文档修改
style: 代码格式修改, 注意不是 css 修改
test: 测试用例修改
chore: 其他修改, 比如构建流程, 依赖管理
```



### （3）分支操作

```shell
git branch 查看本地所有分支
git branch -r 查看远程所有分支
git branch -a 查看本地和远程所有分支
git merge <分支名> 合并分支
git merge --abort 合并分支出现冲突时，取消合并，一切回到合并前的状态
git branch <新分支名> 基于当前分支，新建一个分支
git checkout --orphan <新分支名> 新建一个空分支（会保留之前分支的所有文件）
git branch -D <分支名> 删除本地某个分支
git push <远程库名> --delete <分支名> 删除远程某个分支
git branch <新分支名称> <提交ID> 从提交历史恢复某个删掉的某个分支
git branch -m <原分支名> <新分支名> 分支更名
git checkout <分支名> 切换到本地某个分支
git checkout <远程库名>/<分支名> 切换到线上某个分支
git checkout -b <新分支名> 把基于当前分支新建分支，并切换为这个分支
```



### （4）远程操作

```shell
git remote -v 显示所有远程仓库
git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并
git fetch 获取线上最新版信息记录，不合并
git push [remote] [branch] 上传本地指定分支到远程仓库
git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突
git push [remote] --all 推送所有分支到远程仓库
```



### （5）撤销操作

```shell
git checkout [file] 恢复暂存区的指定文件到工作区
git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区
git checkout . 恢复暂存区的所有文件到工作区
git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
git reset --hard 重置暂存区与工作区，与上一次commit保持一致
git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支
reset：真实硬性回滚，目标版本后面的提交记录全部丢失了
revert：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有
```



### （6）存储操作

```shell
git stash 暂时将未提交的变化移除
git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏
git stash list 查看所有储藏中的工作
git stash apply <储藏的名称> 取出储藏中对应的工作状态进行恢复，不会删除储藏
git stash clear 清空所有储藏中的工作
git stash drop <储藏的名称> 删除对应的某个储藏
```



# 十、TypeScript

## 1、type和interface

1. interface可以重复声明，type不可以；
2. 继承方式不同，interface使用extends实现，type使用交叉类型&方式；
3. 性能不同，对象扩展情况下，接口继承比交叉继承性能更好；
4. 使用场景不同，建议用interface描述对象对外暴露的接口，使用type将一组类型重命名；
5. type可以定义基本类型，interface只能定义对象类型；

```typescript
interface iMan {
  name: string;
  age: number;
}
// 接口可以进行声明合并
interface iMan {
  hobby: string;
}

type tMan = {
  name: string;
  age: number;
};
// type不能重复定义
// type tMan = {}

// 继承方式不同,接口继承使用extends
interface iManPlus extends iMan {
  height: string;
}
// type继承使用&，又称交叉类型
type tManPlus = { height: string } & tMan;

const aMan: iManPlus = {
  name: "aa",
  age: 15,
  height: "175cm",
  hobby: "eat",
};

const bMan: tManPlus = {
  name: "bb",
  age: 15,
  height: "150cm",
};
```



## 2、any、unknown、never

​	any和unknown在TS中属于最顶层的Top Type，即所有的类型都是它们的子类型。而never相反，作为Bottom Type是所有类型的子类型。



## 3、常见工具类型

1. Partial：满足部分属性（一个都没满足也可）即可；
2. Required：所有属性都需要
3. Readonly：包装后的所有属性只读
4. Pick：选取部分属性
5. Omit：去除部分属性
6. Extract：交集
7. Exclude：差集



# 项目

## 1、模块化

​	模块化的目的是将程序划分为一个个小的结构。在这些结构中编写自己的逻辑代码，有自己的作用域，不会影响到其他的结构。同时这些结构可以将自己希望暴露的函数、变量、对象等导出给其他结构使用，也可通过某种方式，将另外结构中的函数、变量、对象等导入使用。



## 2、微前端

常见的微前端实现方案：

1. 基于iframe的完全隔离，iframe是浏览器自带的功能，使用简单，隔离完美，不过它无法保持路由状态，页面一刷新状态就丢失，同时iframe中的状态无法突破对应的应用，同时整个应用是全量加载，速度慢；
2. 基于single-spa路由劫持的方案。qiankun就是基于这种方案实现的，通过对single-spa做一层封装，根据执行环境的修改，来解析微应用的资源，实现了JS沙箱、样式隔离等特性；
3. 借鉴WebComponent思想的micro-app，通过CustomElement结合自定义的ShadowDom，将微前端封装成一个类Web Component组件；



## 3、taro如何将react代码转换成其他平台代码

​	React将其核心功能分成了三部分：React Core（负责处理核心API、与终端平台和渲染解耦，提供了createElement、createClass、Component、Children等方法）、React Renderer（渲染器，定义了React Tree如何构建以接轨不同平台，有React-dom、React-Natvie等）、React Reconciler（调和器，负责diff算法，接驳patch行为。为渲染器提供基础计算能力，主要有16版本之前的Stack Reconciler和16及其之后的Fiber Reconciler）。React团队将Reconciler作为一个单独的包发布，任何平台的渲染器函数只要在HostConfig（宿主配置）内置基本方法，就可以构造自己的渲染逻辑。有了react-reconciler的支持。Taro团队就是提供了taro-react（实现了HostConfig）包来连接react-reconciler和taro-runtime。开发者写的React代码，Taro通过CLI将代码进行webpack打包，taro实现了一套完整的DOM和BOM API在各个平台的适配，打包完之后，就可以将程序渲染到对应的平台上。 核心就在于对输入的源代码的语法分析，语法树构建，随后对语法树进行转换操作再解析生成目标代码的过程。



## 4、token可以放在cookie里吗

​	第一时间要想到安全问题。通常回答不可以，因为存在CSRF（跨站请求伪造）风险，攻击者可以冒用Cookie中的信息来发送恶意请求。解决CSRF问题，可以设置同源检测（Origin和Referer认证），也可以设置Samesite为Strict。最好就是不把token放在cookie里。



## 5、前端埋点

埋点方案：

1. 手动埋点（侵入性强，和业务关联，用于需要精确搜集并分析数据，不过该方式耗时耗力，容易出现误差，后续需要调整，成本高）；
2. 可视化埋点（提供一个可视化的埋点控制台，只能在可视化平台已支持的页面进行埋点）；
3. 无埋点（全埋点，监控页面发生的一切行为，优点是前端只需要处理一次埋点脚本，不过数据量过大会产生大量的脏数据，需要后端进行数据清洗）；

埋点长传采用img方式来上传，首先所有浏览器都支持Image对象，并且记录的过程很少出错，同时不存在跨域问题，请求Image也不会阻塞页面的渲染。建议使用1*1像素的GIF，其体积小。

现在的浏览器如果支持Navigator.sendBeacon(url, data)方法，优先使用该方法来实现，它的主要作用就是用于统计数据发送到web服务器。当然如果不支持的话就继续使用图片的方式来上传数据。



