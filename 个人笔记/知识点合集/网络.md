# 一、HTTP

## 1、基本概念

​	http超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

### （1）优点

- 简单易用：HTTP 协议使用简单，易于学习和使用。它基于文本，可读性好，便于调试和测试。
- 跨平台支持：HTTP 协议是跨平台的，可以在不同的操作系统和设备上使用，包括桌面、移动设备和嵌入式设备。
- 可扩展性：HTTP 协议是可扩展的，可以通过添加新的请求方法、头部字段等来扩展协议。
- 可靠性：HTTP 协议使用 TCP 协议作为传输层协议，具有可靠性和数据完整性保障。
- 支持缓存：HTTP 协议支持缓存机制，可以减少网络传输量和响应时间，提高网站的性能和用户体验。



### （2）缺点

- 性能瓶颈：HTTP 协议使用的是请求-响应模式，每个请求和响应都需要建立和关闭连接，这样会增加网络延迟和连接建立的开销，降低性能。
- 安全性差：HTTP 协议不具备安全性，数据在传输过程中容易被窃听和篡改，需要使用 HTTPS 协议进行加密保护。
- 明文传输：HTTP 协议使用明文传输，容易被中间人攻击和窃听，可能泄露用户隐私。
- 无状态：HTTP 协议是无状态的，每个请求和响应之间是独立的，服务器无法知道两个请求是否来自同一个客户端，需要使用 Cookie 或 Session 等技术来保存状态信息。



## 2、请求头

| 协议头            | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| Accept            | 可接受的响应内容类型                                         |
| Accept-Charset    | 可接受的字符集                                               |
| Accept-Encoding   | 可接受的响应内容的编码方式                                   |
| Authorization     | HTTP 协议中需要认证资源的认证信息                            |
| Cache-Control     | 指定当前的请求/回复中是否使用缓存机制                        |
| Connection        | 客户端(浏览器)想要优先使用的连接类型                         |
| Cookie            | 由之前服务器通过Set-Cooki设置的一个HTTP协议Cookie            |
| Content-Type      | 请求体的 MIME 类型 (用于 POST 和 PUT 请求中)                 |
| Host              | 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口 是对应的服务的标准端口(80)，则端口号可以省略 |
| If-Modified-Since | 允许在对应的资源未被修改的情况下返回 304 未修改              |



## 3、响应头

| 协议头        | 说明                                  |
| ------------- | ------------------------------------- |
| Date          | 表示消息发送的时间                    |
| server        | 服务器名称                            |
| Connection    | 浏览器与服务器之间连接的类型          |
| Cache-Control | 指定当前的请求/回复中是否使用缓存机制 |
| Content-Type  | 表示后面的文档属于什么类型            |



## 4、内容类型Content-Type

​	实体头部用于指示资源的媒体类型，在响应中Content-type标头告诉客户端实际返回的内容类型，浏览器会在某些情况下进行媒体类型查找，并不一定遵循此标题的值。

### （1）application/x-www-form-urlencoded

浏览器原生form表单，提交的数据放在body里面，按照key1=val1&key2=val2的格式进行编码；



### （2）multipart/form-data

该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式；



### （3）application/json

服务器消息主体是序列化后的 JSON 字符串；



### （4）text/xml

该种方式主要用来提交 XML 格式的数据；



## 5、常见HTTP请求方法

- GET：请求一个指定资源的表示形式，只被用于获取数据；
- HEAD：与GET请求的响应相同的响应，但没有响应体；
- POST：将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用；
- PUT：用有效载荷请求替换目标资源的所有当前表示；
- DELETE：删除指定资源；
- PATCH：修改指定资源；



## 6、HTTP请求报文

请求报文由三个部分组成：

- 请求行
  - HTTP协议版本号、请求方法和请求的URI。指定了客户端希望服务器执行的操作；                                                                   
- 消息报头
  - 包含一系列请求的元数据信息，比如请求时间、内容类型、内容长度、缓存控制等，可以被用来控制请求的行为和处理方式；
- 请求正文
  - 客户端发送给服务器的实际数据，可以是HTML表单数据、JSON数据、XML数据等，请求正文类型和格式由消息报头中的Content-Type字段指定；

# 二、HTTPS

## 1、基本概念

​	以安全为目标的 HTTP 通道，是 HTTP 的安全版，HTTPS 的 SSL 加密是在传输层实现的。 HTTPS 协议的主要作用是建立一个信息安全通道，来确保数据的传输和网站的真实性。



## 2、工作原理

客户端使用HTTPS与Web服务器通信步骤：

1. 客户使用HTTPS的URL访问服务器，要求服务器建立SSL链接；
2. 服务器接收到客户端请求后，选取加密算法和HASH算法，将网站的身份信息以证书形式返回给客户端，包含网络地址、加密公钥以及颁发机构等；
3. 客户端收到服务器返回的证书
   1. 验证证书合法性；
   2. 如果证书受信任，客户端生成一串随机数密码，并用公钥加密；
   3. 使用约定好的HASH计算握手信息；
   4. 使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给服务端；
4. 服务端接收到客户端发来的数据
   1. 使用私钥将信息解密，提取密码；
   2. 使用密码解密客户端发送的信息，验证HASH是否和客户端发来的一致；
   3. 使用密码加密握手信息返回给客户端；
5. 客户端解密并计算握手信息的HASH，如果与服务端发来的HASH一致，握手结束；
6. 使用随机密码和对称加密算法对传输的数据加密传输；



## 3、协议优缺点

### （1）优点

1. 可以认证用户和服务器，确保数据发送到正确的客户端和服务器；
2. HTTPS协议由HTTP+SSL协议构建而成，比HTTP要安全，可以防止数据在传输过程中被窃取和改变，确保数据完整性；
3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本；



### （2）缺点

1. 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电；
2. 缓存不如 http 高效，会增加数据开销；
3. SSL证书也需要钱，功能越强大的证书费用越高；
4. SSL证书需要绑定 IP，不能在同一个IP上绑定多个域名，ipv4 资源支持不了这种消耗；





# 三、网络通信

## 1、HTTP和HTTPS区别

1. HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密，相对更安全；
2. HTTP和HTTPS使用连接方式不同，默认端口源也不一样，HTTP是80端口，HTTPS是443；
3. HTTPS由于需要涉及加密和多次握手，性能不如HTTP；
4. HTTPS需要SSL加密，SSL证书需要钱，功能越强大费用越高；



## 2、TCP和UDP区别

1. TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接；
2. TCP提供可靠的服务，传送数据无差错、不丢失、不重复且按序到达，适合大数据量的交换；而UDP尽最大努力交付，不保证可靠性；
3. TCP面向字节流；UDP面向报文，并且网络出现拥塞不会使得发送速率降低，适合IP电话和视频会议等；
4. TCP只能是1对1；UDP支持1对1，1对多；
5. TCP首部较大，为20字节；UDP只有8字节；



## 3、HTTP发展

### （1）HTTP/1

#### 1.1、HTTP/0.9

1991年提出，用来在网络之间传递HTML超文本内容。

**特点：**

- 只有一个请求行，没有请求头和请求体；
- 没有返回头；
- 返回的文件内容以ASCII字符流来传输；



#### 1.2、HTTP/1.0

万维网的发展推动新协议的要求。

**特点：**

- 增加请求头告诉服务器期待返回的文件类型、压缩形式和编码格式；
- 增加了响应头和响应体来支持不同类型的数据；
- 引入状态码；
- 提供缓存机制；
- 增加了用户代理字段；



#### 1.3、HTTP/1.1

**特点：**

- 增加了持久连接的方法，在请求头和相应头中添加`Connection: Keep-Alive`属性，保证连接不中断；
- 提供虚拟主机的支持；
- 对动态生成的内容提供了完美支持；
- 客户端增加cookie和安全机制；



### （2）HTTP/2

1. **增加二进制分帧层**：会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码，转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器；
2. **多路复用**：当收到一个优先级高的请求时，服务器可以暂停之前的请求来优先处理关键资源的请求，然后根据 ID 编号将帧的数据返回给对应的请求，最后将所有相同ID的帧合并为一条完整的信息；
3. 可以**设置请求的优先级**;
4. **头部压缩**：对请求头和相应头进行了压缩，提升了大量请求时的传输效率；
5. **服务器推送**：可以直接将数据提前推送到浏览器；





### （3）HTTP/3

​	HTTP3.0核心是QUIC协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层UDP上的协议；

- 该协议实现了类似TCP的流量控制、传输可靠性功能；
- 集成了TLS加密功能；
- 实现了HTTP/2中的多路复用功能；
- 实现了快速握手能力；



### （4）1.0和1.1的区别

#### 1.1、连接方面

​	http1.0默认使用非持久连接，而1.1默认使用持久连接。http1.1通过使用持久连接来使多个http请求复用同一个TCP连接，从而避免使用非持久连接时每次需要建立连接的延时。



#### 1.2、资源请求方面

​	在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206，这样就方便了开发者自由的选择以便于充分利用带宽和连接。



#### 1.3、缓存方面

​	在 http1.0 中主要使用 header 里的 If-Modified-Since（标识符-协商缓存）、Expires（缓存到期时间-强缓存） 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。



#### 1.4、http1.1新增host字字段

用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。



#### 1.5、请求方法方面

新增PUT、HEAD、OPTIONS等请求方法。



### （5）1.1和2.0的区别

#### 2.1、二进制协议

HTTP/2是一个二进制协议，1.1中报文头信息必须是文本(ASCII编码)，数据体可以是文本、也可以是二进制。HTTP/2则是一个彻底的二进制协议，头信息和数据体都是二进制统称为“帧”，可以分为头信息帧和数据帧。



#### 2.2、多路复用

HTTP/2实现了多路复用，HTTP/2仍复用TCP连接，但是在一个连接中，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序发送，避免队头堵塞问题。



#### 2.3、数据流

 HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。



#### 2.4、头信息压缩

HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，同样的内容，每次请求都必须附带，会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息**使用 gzip 或 compress 压缩后再发送**；另一方面，**客户端和服务器同时维护一张头信息表**，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。



#### 2.5、服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。



## 4、队头堵塞

​	队头堵塞是指在HTTP/1.x协议中，一个请求在发送到服务器后，需要等待前面的请求响应完成后才能得到响应，即使后面的请求已经准备好了，这种情况下，即使服务器已经处理完后面的请求并准备好了响应，但是由于前面请求的响应还没完成，后面的请求只能等待，从而导致效率低下；

​	队头堵塞的原因是HTTP1.x协议采用了串行请求和响应方式，在同一时间只能处理一个请求，意味着如果前面的请求处理时间较长，后面的请求就必须等待，从而导致队头堵塞。

​	为了解决队头堵塞问题，HTTP/2协议引入了多路复用机制，HTTP/2允许在同一连接上同时发送多个请求和响应，且不必按照顺序等待前面的请求响应完成，这样显著提高了性能和效率。

<center>HTTP/1.x协议</center>

![image-20230701214603603](https://raw.githubusercontent.com/Rainchen0504/picture/master/202307012146035.png)

<center>HTTP/2协议</center>

![image-20230701214616713](https://raw.githubusercontent.com/Rainchen0504/picture/master/202307012146926.png)



## 5、GET和POST区别

1. GET参数通过URL传递，POST放在请求体中；
2. GET请求在URL中传递的参数是有长度限制的，而POST没有；
3. GET比POST更不安全，因为参数直接暴露在URL中，所以不能用来传递敏感信息；
4. GET请求只能进行URL编码，而POST支持多种编码方式；
5. GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留；
6. GET 和 POST 本质上就是TCP链接，但是由于HTTP的规定和浏览器/服务器的限制，导致GET 产生一个TCP数据包，而POST产生两个TCP数据包；



## 6、状态码

### （1）状态列表

| 状态码 | 说明                                                         |
| :----- | ------------------------------------------------------------ |
| 200    | 客户端请求成功                                               |
| 201    | 请求成功，通常是POST请求创建了一个新资源                     |
| 301    | 请求资源URL**永久更改**，响应中会给出新URL                   |
| 302    | 请求资源URL**临时更改**，应该在将来的请求中继续使用相同的URL |
| 304    | 使用缓存，和上次响应比没有被修改，可以继续使用相同的缓存     |
| 400    | 客户端有语法错误，服务器无法或不进行处理（常见的传参错误，没有和后台要求保持一致） |
| 401    | 未授权错误，客户端必须携带身份信息，提供身份验证才能获得请求响应 |
| 403    | 客户端知道身份信息，但是没有权限访问，拒绝提供服务           |
| 404    | 服务器找不到请求资源（输入错误的URL）                        |
| 500    | 服务器遇到不可预期的错误                                     |
| 503    | 服务器不可用，可能处于维护或者重载状态，暂时无法访问         |



### （2）301和302区别

- 301 被请求的资源<font color=pink>已**永久移动**到新位置</font>，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。

- 302 请求的资源<font color=pink>现在**临时从不同的 URI 响应**请求</font>。由于这样的重定向是临时的， 客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。

**总结**：<font color=skyblue>**301 是永久重定向，而 302 是临时重定向**</font>。 301比较常用的场景是使用域名跳转。302用来做临时跳转比如未登陆的用户访问用户中心，重定向到登录页面。



## 7、AJAX

### （1）发送请求

ajax就是用js发送异步的网络请求：

```js
// 实例化ajax对象
let xhr = new XMLHttpRequest()
// 设置请求方法和地址
xhr.open('post', '请求地址')
// 设置请求头（仅限于post请求）
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")
// 发送请求
xhr.send("username=admin&password=123456")
// 回调函数
xhr.onreadstatechange = function() {
  if(xhr.readState == 4 && xhr.status == 200) {
    console.log(xhr.responseText)
  }
}
```



### （2）取消请求的方法

1. 原生取消请求，使用abort方法

   ```js
   let xhr = new XMLHttpRequest()
   xhr.abort() // 取消请求方法
   ```

2. axios取消请求

   1. 使用`cancelToken`：在发送请求时，通过配置`cancelToken`参数指定一个`CancelToken`对象，然后在需要取消时调用`cancel()`方法

      ```js
      const CancelToken = axios.CancelToken;
      const source = CancelToken.source();
      
      axios.get('地址', {
        cancelToken: source.token
      }).then(res => {
        console.log(res)
      }).catch(err => {
        console.log(err)
      })
      
      // 取消请求
      source.cancel('取消请求')
      ```

   2. 使用`cancel`方法：Axios请求返回一个cancel函数，该函数可以用来取消请求

      ```js
      const request = axios.get("请求地址");
      
      // 取消请求
      request.cancel("取消请求")
      request.then(res => {
         console.log(res)
      }).catch(err => {
         console.log(err)
      })
      ```

3. 取消请求的意义

   1. 减轻服务器压力；
   2. 减少网络带宽消耗；
   3. 提高用户体验；
   4. 避免重复请求；

   

## 8、三次握手和四次挥手







## 13、RESTFUL

​	REST是Web服务的一种新的架构风格（一种思想）。RESTful是一种常见的REST应用，是遵循REST风格的web服务，REST式的web服务是一种ROA（面向资源的架构）。

### （1）RESTful风格主要原则

- 对网络上所有的资源都有一个资源标志符；
- 对资源的操作不会改变标识符；
- 同一资源有多种表现形式；
- 所有操作都是无状态的；

### （2）REST资源操作

| http方法 | 资源操作 | 幂等 | 安全 |
| -------- | -------- | ---- | ---- |
| GET      | SELECT   | 是   | 是   |
| POST     | INSERT   | 否   | 否   |
| PUT      | UPDATE   | 是   | 否   |
| DELETE   | DELETE   | 是   | 否   |

RESTful中根据操作资源的不同，使用不同的http方法，其传输的媒介一般使用json

### （3）接口案例

```js
// 传统URL
http://127.0.0.1/user/query/1 GET 根据用户id查询用户数据
http://127.0.0.1/user/save POST 新增用户
http://127.0.0.1/user/update POST 修改用户信息
http://127.0.0.1/user/delete GET/POST 删除用户信息
```

```js
// RESTful
http://127.0.0.1/user/{id} GET 根据用户id查询用户数据
http://127.0.0.1/user POST 新增用户
http://127.0.0.1/user PUT 修改用户信息
http://127.0.0.1/user DELETE 删除用户信息  OR http://127.0.0.1/user/{id} DELETE 删除用户信息
```



# 四、网络安全

## 1、XSS和CSRF攻击和防范

### （1）XSS

#### 1.1、定义

XSS即跨站脚本攻击，攻击者通过在目标网站注入恶意脚本，在用户浏览网页的时候进行攻击，获取 cookie，或者其他用户身份信息。

可以分为存储型和反射型：

- 存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击；
- 反射型的话不存储在数据库中，往往表现为将攻击代码放在 url 地址的请求参数中；



#### 1.2、常用攻击方法

1. 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入；
2. 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签；
3. 在标签的 href、src 等属性中，包含 `javascript:` 等可执行代码；
4. 在 onload、onerror、onclick 等事件中，注入不受控制代码；



#### 1.3、防范手段

1. 输入过滤；

2. 纯前端渲染，把代码和数据分隔开；

3. 对 HTML 做充分转义；

4. 避免js在字符串中拼接不可信数据；

5. 输入内容长度控制；

6. 在HTTP头部上配置`set-cookie`，设置两个属性：

   httponly：该属性可禁止JavaScript访问Cookie，故可以保护Cookie不被嵌入的恶意代码所获取；

   secure：该属性告诉客户端浏览器仅当在https请求时发送Cookie；



### （2）CSRF

#### 2.1、定义

CSRF即跨站请求伪造，黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求比如用户登录了一个网站后，立刻访问另一个攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候 CSRF 就产生了。



#### 2.2、常用攻击方法

1. 自动发起Get请求，比如在图片中隐藏转账请求接口，加载图片时自动发起请求；
2. 自动发起Post请求，黑客站点伪造POST请求，当用户打开站点时会自动提交 POST 请求；
3. 引诱用户点击链接，常见就是各种邮件链接等；



#### 2.3、防范手段

1. 同源检测，禁止外域（或者不受信任的域名）发起请求，检查HTTP请求头中的Referer（记录Http请求的来源地址值）和Origin属性；
2. 设置Token，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息，因此要求所有的用户请求都携带一个Token，服务器通过校验Token区分请求；
3. 使用验证码；



## 2、中间人机制

​	中间人机制是一种攻击方法，攻击者在通信的两端之间插入自己的设备或软件，窃取通信内容或修改通信内容，而且不被通信双方发现。

### （1）攻击原理

​	攻击原理是通过某种手段，如ARP欺骗，DNS污染、WI-FI伪装等，让受害者的通信数据经过攻击者的设备或软件，攻击者可以在此过程中窃取或修改通信内容。比如攻击者可以窃取用户登录的银行账号和密码或者篡改用户的请求等。



### （2）防范手段

1. 加密通信：使用加密通信协议，比如HTTPS、SSL/TLS等，保护通信内容；
2. 数字证书：使用数字证书验证通信双方的身份；
3. 避免公共WI-FI：尽量避免使用公共Wi-Fi；
4. 安全软件：使用可靠的防火墙软件；



