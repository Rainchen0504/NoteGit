## 26、flex布局

弹性布局用来为盒模型提供最大的灵活性。

### （1）容器属性

- 决定主轴方向

```css
flex-direction: row | row-reverse | column | column-reverse;
```

- 决定轴线排列方向，如何换行

```css
flex-wrap: nowrap | wrap | wrap-reverse;
```

- direction和wrap的简写

```css
flex-flow: <flex-direction> || <flex-wrap>;
```

- 决定水平对齐方式

```css
justify-content: flex-start | flex-end | center | space-between | space-around;
```

- 决定垂直对齐方式

```css
align-items: flex-start | flex-end | center | baseline | stretch;
```

- 多轴线的对齐方式

```css
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
```



### （2）项目属性

- 定义项目的排列顺序。数值越小，排列越靠前，默认为0

```css
order: <integer>;
```

- 放大比例

```css
flex-grow: <number>;
```

- 缩小比例

```css
flex-shrink: <number>;
```

- `flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为0 1 auto。后两个属性可选

```css
flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
```



## 27、BFC

### （1）定义

块级格式上下文，是一个独立的渲染区域，有一定的布局规划，与区域外外部毫不相干。



### （2）特征

1. BFC是一个独立的容器，容器内子元素不会影响容器外的元素，反之亦是如此；
2. 盒子从顶端开始垂直的一个一个的排列，盒子之间垂直的间距是由margin决定的；
3. 在同一个BFC中，两个相邻的块级盒子的垂直外边距会发生重叠；
4. BFC区域不会和float box发生重叠；
5. BFC能够识别并包含浮动元素，当计算其区域的高度时，浮动元素也可以参与计算；



### （3）产生条件

- float的值不为none；
- position的值不为static或者relative；
- display的值是inline-block、table-cell、flex、table-caption或者inline-flex；
- overflow的值不为visible；



### （4）作用

1. 解决高度坍塌问题；
2. 清除内部浮动；
3. 自适应多栏布局；



## 28、垂直居中方法

### （1）margin:auto

```css
.parent {
  position: relative;
  width: 500px;
  height: 400px;
  background: blue;
}
.child {
  background: red;
  width: 50px;
  height: 50px;
  position: absolute;
  top: 0px;
  bottom: 0px;
  left: 0px;
  right: 0px;
  margin: auto;
}
```



### （2）margin负值/translate偏移

```css
.div2 {
  width: 500px;
  height: 400px;
  position: relative;
}

.span2 {
  width: 180px;
  height: 80px;
  background-color: #746;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```



### （3）利用flex

```css
.div4 {
  width: 300px;
  height: 200px;
  background: black;
  display: flex;
  align-items: center;
  justify-content: center;
}
.span4 {
  width: 50px;
  height: 50px;
  background: red;
}
```



### （4）line-height

```css
.div5 {
  width: 300px;
  height: 200px;
  border: 1px solid #546461;
  font-size: 0px;
  text-align: center;
  line-height: 200px;
}
.span5 {
  display: inline-block;
  width: 100px;
  height: 50px;
  font-size: 16px;
  background-color: red;
  line-height: 50px;
  vertical-align: middle;
}
```



## 29、JS动画和CSS3动画

### （1）JS动画

- 优点：
  - JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的；
  - 动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成；
  - CSS3有兼容性问题，而JS大多时候没有兼容性问题；
- 缺点
  - js是单线程的脚本语言，当js在浏览器主线程运行时，主线程还有其他需要运行的js脚本、样式、计算、布局、交互等一系列任务，对其干扰线程可能出现阻塞，造成丢帧的情况；
  - js在做动画的时候，其复杂度是高于css3的，需要考虑一些计算，操作等方便问题；



### （2）CSS3动画

- 优点
  - 浏览器可以对动画进行优化；
  - 代码相对简单,性能调优方向固定；
  - 对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码；
- 缺点
  - 代码冗长。如果想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重；
  - 运行过程控制较弱，无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告；



## 30、块元素和行内元素

### （1）块元素

独占一行，并且自动填满父元素，可以设置 margin 和 pading 以及高度和宽度，可以包含行内元素和块元素；

常见的有：`div p h1-h6 ul ol li tr td hr`



### （2）行内元素

不会独占一行，width 和 height 会失效，并且在垂直方向的 padding 和 margin 会失效，只能包含行内元素或文字；

常见的有：`span img a input i select strong`



## 31、多行元素的文本省略号

```css
display: -webkit-box;
overflow: hidden;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
width: 100px;
```



## 32、元素隐藏

### （1）visibility=hidden

该元素隐藏起来但是不会改变页面布局，不会触发该元素已经绑定的事件；

### （2）opacity=0

把元素隐藏起来，不会改变页面布局，如果元素绑定了事件（比如点击事件），那么点击该区域也能触发点击事件；

### （3）display:none

把元素隐藏起来，并且会改变页面布局，可以理解为在页面中删除元素；



## 33、双边距重叠问题

多个相邻（兄弟或者父子关系）普通流的块元素垂直方向margin会重叠；

折叠结果为：

1. 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大值；
2. 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；
3. 两个边距一正一负时，折叠结果是两者相加的和；



## 34、position



## 35、判断对象是否存在属性的方法

### （1）`Reflect.has`()

检查一个对象是否有某个属性。包含原型上的属性

```js
Reflect.has({name:"zhang"}, "name")	//true
Reflect.has({name:"zhang"}, "age")	//false
```



### （2）in操作符

检查对象是否包含某个属性，包含就返回true，否则返回false。作用和`Reflect.has()`相同。包含原型上的属性

```js
const obj = {p: 1};
'p' in obj; // true
'toString' in obj; // true
```



### （3）`Object.prototype.hasOwnPerporty()`

判断对象是否具有指定的属性（非继承得到的）。该方法可以正确的区分对象本身的属性和原型的属性。

```js
const obj = { name:"zhang" };
obj.hasOwnProperty('name') // true
obj.hasOwnProperty('toString') // false
```

但是如果对象是`Object.create(null)`创建的，就不能使用`hasOwnProperty()`了。

```js
let obj = Obejct.create(null);
obj.p = 1;
obj.hasOwnProperty('p') //报错
```



### （4）`Object.prototype.hasOwnPerporty.call()`

原型链上真正的`hasOwnProperty`方法

```js
Object.prototype.hasOwnPerporty.call(obj, 'p')
```



### （5）`Object.hasOwn()`

用于替代`Object.prototype.hasOwnPerporty()`的方法，如果指定的对象具有作为其自身属性的指定属性，返回true，否则返回false

```js
const object1 = {prop: 'exists'};
console.log(Object.hasOwn(object1, 'prop')); // true
console.log(Object.hasOwn(object1, 'toString'));// false
```





## 99、响应式原理

当`render`渲染该数据时，出发getter进行依赖收集，收集依赖的目的是将观察者watcher放到当前订阅者Dep的管理下形成一种关联关系。

当修改值的时候，会触发setter，setter会通知订阅者Dep中收集到的watcher依赖值发生改变，需要重新渲染视图，watcher调用update函数更新视图，update中包含patch的过程（diff算法、队列异步更新）







## 1、GET和POST请求区别

### （1）应用场景

GET请求是一个幂等的请求。一般GET请求用于<font color=pink>对服务器资源不会产生影响的场景</font>，比如说请求一个网页的资源。

POST不是一个幂等的请求。一般用于<font color=pink>对服务器资源会产生影响的情景</font>，比如用户注册这一类操作。

幂等是指一个请求方法多次执行和仅执行一次的效果完全相同。

### （2）是否缓存

浏览器一般会对 GET 请求缓存，但很少对 POST 请求缓存。

### （3）传参方式不同

GET 通过查询字符串传参，POST 通过请求体传参。

### （4）安全性

GET 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 POST 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。

### （5）请求长度

浏览器由于对 url 长度的限制，所以会影响 GET 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。

### 补充⚠️：GET请求URL长度限制原因

IE浏览器队URL长度限制是**2083字节**，忧郁IE浏览器对URL长度的允许值是**最小的**，因此只要URL不超过2083字节，其他浏览器就不会有问题。

### （6）参数类型

GET 请求只允许ASCII字符，POST 的参数传递支持更多的数据类型(如文件、图片)。



## 2、常见HTTP请求头和响应头

### （1）请求头Request Header

- Accept：浏览器能够处理的内容类型
- Accept-Charset：浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookie：当前页面设置的任何Cookie
- Host：发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

### （2）响应头Responses Header

- Date：表示消息发送的时间
- server：服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache-Control：控制HTTP缓存
- Content-Type：表示后面的文档属于什么类型



## 3、常见内容类型content-type

### （1）application/x-www-form-urlencoded

​	浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

### （2）multipart/form-data

该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

### （3）application/json

服务器消息主体是序列化后的 JSON 字符串。

### （4）text/xml

该种方式主要用来提交 XML 格式的数据。



## 4、常见HTTP请求方法

GET：向服务器获取数据；

POST：发送数据给服务器，通常会造成服务器资源的新增修改；

PUT：创建一个新的资源或用请求的参数资源替换目标资源；

DELETE：删除指定资源；

PATCH：对资源进行部分修改；

HEAD：获取报文首部，与GET相比，不返回报文主体部分；使用场景是比如下载一个大文件前，先获取其大小再决定是否要下载，以此可以节约宽带资源；

TRACE：沿着通往目标资源的路径进行信息回环测试，提供一个有用的调试机制；

CONNECT：要求在与代理服务器通信时建立**管道**，使用**管道**进行TCP通信；(把服务器作为跳板，让服务器代替用户去访问其他网页，之后把数据原原本本的返回给用户)

OPTIONS：(浏览器自动执行)、询问支持的请求方法，用来跨域请求、预检请求、判断目标是否安全



## 5、AJAX

### （1）发送请求

ajax就是用js发送异步的网络请求；

A--Asynchronous 异步；J--Javascript；A--And；X--XML与XMLHttpRequest；

```js
// 创建实例化ajax对象
let xhr = new XMLHttpRequest()
// 设置请求方法和地址
xhr.open("post","http://www.liulongbin.top:3309/api/login")
// 设置请求头（post请求才需要设置）
 xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
// 发送请求
xhr.send("username=admin&password=123456")
// 回调函数
xhr.onreadstatechange = function () {
  if (xhr.readState == 4 && xhr.status == 200) {
    console.log(xhr.responseText)
  }
}
```

### （2）取消请求方法

1. 原生取消请求

   ```js
   var xhr = new XMLHttpRequest();
   xhr.abort(); // 取消请求方法
   ```

2. axios取消请求

   1. 使用 CancelToken.source 工厂方法创建 cancel token

      ```js
      const CancelToken = axios.CancelToken;
      const source = CancelToken.source();
      axios.get('/user/123', {
          cancelToken: source.token
      }).catch(function(thrown) {
          if (axios.isCancel(thrown)) {
              console.log('Request canceled', thrown.message);
          } else {
          // 处理错误
          }
      });
      axios.post('/user/123', {
          name: '小明'
      }, {
          cancelToken: source.token
      }) dd 
      // 取消请求（message 参数是可选的）
      source.cancel('canceled by the user'); 
      ```

   2. 传递一个executor函数到CancelToken的构造函数来创建cancel token

      ```js
      const CancelToken = axios.CancelToken;
      let cancel;
      axios.get('/user/12345', {
        cancelToken: new CancelToken(function executor(c) {
          // executor 函数接收一个 cancel 函数作为参数
          cancel = c;
        })
      });
      // cancel the request
      cancel();
      ```

3. 取消请求的意义

   1. 已发出的请求可能仍然会到达后端；
   2. 取消后续的回调处理，避免多余的回调处理（先发出的后返回，导致回调中的数据错误覆盖）
   3. 取消loading效果，以及该请求的其他交互效果，特别是在单页应用中，A页面跳转到B页面之后，A页面的请求应该取消，否则回调中的一些处理可能影响B页面；
   4. 超时处理，错误处理等都省去了，节约资源；







## 7、队头堵塞

### （1）说明

队头堵塞是HTTP基本的“请求-应答”模型导致的。HTTP规定报文必须是“一发一收”，因此形成一个先进先出的“串行”队列。队列中请求是没有优先级的，只有入队的先后顺序，排在最前面的会被优先处理。如果队首发生丢包或延时的情况，队列中所有请求都会跟着一起等待，增加了其他请求的时间成本，造成队头堵塞现象。

### （2）解决方法

- 并发连接：对于一个域名允许分配多个长连接，相当于增加了任务队列，避免一个任务堵塞其他所有任务；
- 域名分片：将域名分出多个二级域名，指向同一台服务器，能够并发的长连接变多，解决队头堵塞问题；



## 8、HTTP和HTTPS区别

1. HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密，相对更安全；
2. HTTP和HTTPS使用连接方式不同，默认端口源也不一样，HTTP是80端口，HTTPS是443；
3. HTTPS由于需要涉及加密和多次握手，性能不如HTTP；
4. HTTPS需要SSL加密，SSL证书需要钱，功能越强大费用越高；



## 9、HTTP优缺点

​	HTTP是超文本传输协议，定义了<font color=blue>客户端和服务器之间交换报文的格式和方式</font>，默认使用80端口，<font color=blue>使用TCP作为传输层协议</font>，保证数据传输的可靠性。

### （1）优点

- 支持客户端/服务器模式；

- **简单快速**。客户向服务器请求服务时，只需传送请求方法和路径，HTTP服务规模小，通信速度很快；

- **无连接**。限制每次连接只处理一个请求，服务器处理完客户的请求并收到客户应答后，断开连接，节省传输时间；

- **无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息，在服务器不需要先前信息时它的应答就比较快；

  **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记；

### （2）缺点

- **无状态**。HTTP是一个无状态协议，HTTP服务器不会保存关于客户的任何信息，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大；
- **明文传输**。协议中的报文使用的是文本形式，直接暴漏给外界，不安全；
- **不安全**。



## 10、HTTP加载多张图片的表现

在HTTP1下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取次数。

在HTTP2下，可以一瞬间加载出很多资源，因为HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。



## 11、HTTP请求报文

请求报文由4部分组成：

- 请求行
  - 请求方法字段、URL字段、HTTP协议版本字段，使用空格分隔，如`GET/index.html HTTP/1.1`。
- 请求头部
  - 请求头部由关键字/值对组成，每行一对，关键字和值用冒号分隔
    - User-Agent：产生请求的浏览器类型；
    - Accept：客户端可识别的内容类型列表；
    - Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
- 空行
- 请求体
  - post、put等请求携带的数据



## 12、HTTP响应报文

响应报文由4部分组成：

- 响应行
  - 由网络协议版本，状态码和状态码原因短语组成，如`HTTP/1.1 200 OK`。
- 响应头
  - 响应部首组成
- 空行
- 响应体
  - 服务器相应的数据



## 13、HTTP两种连接模式

HTTP协议基于TCP/IP，并使用了**请求-应答**的通信模式。

HTTP协议有两种连接模式，<font color=pink>一种是持续连接，一种是非持续连接</font>。

- 非持续连接是服务器必须为每一个请求的对象建立和维护一个全新的连接；
- 持续连接TCP连接默认不关闭，可以被多个请求复用，相对非持续连接可以节约每次建立TCP连接三次握手所花费的时间。



## 14、TCP三次握手四次挥手

### （1）三次握手

- 第一次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；
- 第二次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；
- 第三次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。

### （2）四次挥手

- 第一次挥手：客户端发送一个FIN，关闭客户端到服务端的数据传送，客户端进入等待远端TCP连接终止请求状态；
- 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，进入等待本地用户啊连接终止请求状态；
- 第三次挥手：服务端发送一个FIN，关闭服务端到客户端的数据传送，服务端进入等待先前发送给远端TCP连接终止请求的确认状态；
- 第四次挥手：客户端收到FIN，等待服务端终止TCP连接，发送一个ACK给服务端，服务端进入不连接状态，完成四次挥手；



## 15、URL的组成

1. 协议部分：HTTP或HTTPS
2. 域名部分：可以是域名也可以是IP地址
3. 端口部分：跟在域名后面，可以省略，HTTP默认是80，HTTPS默认是443
4. 虚拟目录部分：从域名后第一个/到最后一个/为止
5. 文件名部分
6. 锚部分：从#开始到最后
7. 参数部分：从？到#之间的部分



## 16、HTTP的keep-alive

**http1.0默认关闭缓存**，需要手动开启，**http1.1之后默认开启**。

### （1）作用

使客户端到服务器端的链接持续有效（长连接），当出现对服务器的后续请求时，keep-Alive功能避免了重新建立链接；

### （2）使用方法

在请求头中加上`Connection:keep-alive`；

### （3）优点

较少的CPU和内存的占用；减少了后续请求的延迟；

### （4）缺点

 本来可以释放的资源仍旧被占用。有的请求已经结束了，但是还一直连接着；

### （5）解决方法

服务器设置过期时间和请求次数，超过这个时间或者次数就断掉连接。



## 17、缓存相关的HTTP请求头

### （1）强缓存

Expires、Cache-Control



### （2）协商缓存

Etag、If-None-Match

Last-Modified、If-Modified-Since



## 17、OSI网络七层模型

ISO于1978年开发的一套标准架构ISO模型，被引<font color=deepred>用来说明**数据通信协议的结构和功能**</font>：

网络群组：物理层、数据链路层、网络层

使用者群组：传输层、会话层、表示层、应用层

![6491686243520_.pic](https://raw.githubusercontent.com/Rainchen0504/picture/master/202306090107885.jpg)





## 15、DNS

域名系统，万维网上作为域名和IP地址相互映射的一个分布式数据库，能够通过域名得到该域名对应的IP地址，而这个过程叫做域名解析；

### 查询过程

1. 搜索浏览器自身的DNS缓存，存在就返回，解析结束；
2. 如果没有缓存，就尝试读区操作系统的hosts文件查看是否存在对应映射关系，如果存在就返回，解析结束；
3. 如果hosts文件不存在映射关系，则查找本地DNS服务器，如果存在域名解析完成；
4. 如果本地DNS服务器还没找到的话，就向服务器发送请求，进行递归查询；



## 14、为什么post请求会发送两次

- 第一次请求为`options`预检请求，状态码为204。
  - 作用1：询问服务器是否支持修改的请求头，如果服务器支持，在二次中发送真正请求；
  - 作用2：检测服务器是否为同源请求，是否支持跨域；

- 第二次为真正的`post`请求。



## 16、CDN

​	`Content Delivery NetWork`——内容分发网络。用户在浏览网站的时候，CDN 会选择一个离用户最近的 CDN 边缘节点来响应用户的请求，这样海南移动用户的请求就不会                                                                                                                          千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上。

**优点**：

1. 解决了跨运营商和跨地域访问的问题，访问延时大大降低。
2. 大部分请求在CDN边缘节点完成，CDN起到分流作用，减轻源服务器的负载。

