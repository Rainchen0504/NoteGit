# HTTP/HTML/浏览器

## 1、http/https

### （1）http和https基本概念

http：超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

https：以安全为目标的 HTTP 通道，是 HTTP 的安全版，HTTPS 的 SSL 加密是在传输层实现的。 HTTPS 协议的主要作用是建立一个信息安全通道，来确保数据的传输和网站的真实性。



### （2）http和https区别

http 传输的数据都是未加密的，也就是明文的。简单来说 https 协议是由 http 和 ssl 协议构建的可进行加密传 输和身份认证的网络协议，比 http 协议的安全性更高。

- https 协议需要 ca 证书，费用较高。
- http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。 使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443
- http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。



### （3）https协议工作原理

客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，

1. 客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。
2. web 服务器接收到客户端的请求之后，会将网站的证书(证书中包含了公钥)，返回给客户端。
3. 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加 密会话密钥，并传送给网站。
4.  web 服务器通过自己的私钥解密出会话密钥。
5.  web 服务器通过会话密钥加密与客户端之间的通信。



### （4）https协议优缺点

#### 优点：

1. 可以认证用户和服务器，确保数据发送到正确的客户机和服务器；
2. HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；
3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本；

#### 缺点：

1. https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电；
2. https 缓存不如 http 高效，会增加数据开销；
3. SSL 证书也需要钱，功能越强大的证书费用越高；
4. SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗；



## 2、TCP和UDP的区别

1. TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接；
2. TCP提供可靠的服务，传送数据无差错、不丢失、不重复且按序到达，适合大数据量的交换；UDP尽最大努力交付，但是不保证可靠；
3. TCP面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低，适合IP电话和视频会议等；
4. TCP只能是1对1对，UDP支持1对1，1对多；
5. TCP首部较大，为20字节，UDP只有8字节；
6. TCP 是面向连接的可靠性传输，而 UDP 是不可靠的；



## 3、http发展

### （1）HTTP/1

#### 1.1、HTTP/0.9

1991年提出，用来在网络之间传递HTML超文本内容。

特点：只有一个请求行，没有请求头和请求体；没有返回头；返回的文件内容以ASCII字符流来传输。



#### 1.2、HTTP/1.0

万维网的发展推动新协议的要求。

特点：增加请求头告诉服务器期待返回的文件类型、压缩形式和编码格式；增加了响应头和响应体来支持不同类型的数据；引入状态码；提供缓存机制；增加了用户代理字段；



#### 1.3、HTTP/1.1

特点：增加了持久连接的方法，在请求头和相应头中添加`Connection: Keep-Alive`保证连接不中断；提供虚拟主机的支持；对动态生成的内容提供了完美支持；客户端增加cookie和安全机制；



### （2）HTTP/2

特点：

1. 增加二进制分帧层：会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码，转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器；
2. 多路复用：当收到一个优先级高的请求时，服务器可以暂停之前的请求来优先处理关键资源的请求，然后根据 ID 编号将帧的数据返回给对应的请求，最后将所有相同ID的帧合并为一条完整的信息；
3. 可以设置请求的优先级；
4. 头部压缩：对请求头和相应头进行了压缩，提升了大量请求时的传输效率；
5. 服务器推送：可以直接将数据提前推送到浏览器；



## 4、状态码

| 状态码 | 说明                                                         |
| :----- | ------------------------------------------------------------ |
| 200    | 客户端请求成功                                               |
| 201    | 请求成功，通常是POST请求创建了一个新资源                     |
| 301    | 请求资源URL永久更改，响应中会给出新URL                       |
| 302    | 请求资源URL临时更改，应该在将来的请求中继续使用相同的URL     |
| 304    | 使用缓存，和上次响应比没有被修改，可以继续使用相同的缓存     |
| 400    | 客户端有语法错误，服务器无法或不进行处理（常见的传参错误，没有和后台要求保持一致） |
| 401    | 未授权错误，客户端必须携带身份信息，提供身份验证才能获得请求响应 |
| 403    | 客户端知道身份信息，但是没有权限访问，拒绝提供服务           |
| 404    | 服务器找不到请求资源（输入错误的URL）                        |
| 500    | 服务器遇到不可预期的错误                                     |
| 503    | 服务器不可用，可能处于维护或者重载状态，暂时无法访问         |



## 5、fetch请求发送2次

fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功：

用 fetch 的 post 请求的时候，导致 fetch 第一次发送了一个 Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。





## 6、Cookie、sessionStorage和localStorage

#### Cookie

​	cookie是客户端与服务端进行会话使用的一个能够在浏览器本地化存储的技术。cookie是服务端发送给客户端的文本文件，但是只能存储4kb的数据，目的是用于辨别用户身份，记录跟踪用户状态，记录访问次数等操作。

​	cookie的内容包括：名字name、值value、过期时间expires、路径path和域domain。路径和域一起构成cookie的作用范围。一般cookie存储在内存中，设置过期时间则存储在硬盘里。浏览器页面关闭也不会失效，直到设置的过期时间后才失效，若不设置过期时间，则有效期是浏览器窗口的会话期间，关闭浏览器窗口就失效。

​	原理：客户端请求服务器时，如果服务器需要记录用户状态，就使用response向客户端浏览器发一个cookie。而客户端浏览器会把cookie保存起来。当浏览器再请求服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。

```js
//设置cookie
setCookie(name,value,expiredays){
  //设置时间天为过期时间
  let exdate = new Date()
  exdate.setDate(exdate.getDate() + expiredays)
  document.cookie=name + '=' + escape(value)+((expiredays==null) ? "" : ";expires="+exdate.toGMTString())
}

//获取cookie
getCookie(name){
  let start = document.cookie.indexOf(name + '=')
  let end = document.cookie.indexOf(';', start)
  if(end = -1){
    end = document.cookie.length
  }
  return unescape(document.cookie.substring(start,end))
}
```



#### sessionStorage

​	sessionStorage在当前会话下有效，引入一个“浏览器窗口的概念”，sessionStorage是在同源的同窗口中始终存在的数据，只要浏览器不关闭，即使刷新或进入同源的另一个页面，数据仍存在。如果同时打开独立的窗口即使是同一个页面，sessionStorage的对象也是不同的。关闭窗口后sessionStorage就会被销毁。

```js
sessionStorage.setItem('sessionName', 'zhang')	//保存
sessionStorage.getItem('sessionName')	//取值
sessionStorage.removeItem('sessionName')	//删除值
sessionStorage.clear()	//清除所有
```



#### localStorage

​	localStorage的生命周期是永久，除非手动去清除，否则永久存在，存储大小5mb，仅在客户端上存储，不参与服务器通信。

```js
localStorage.setItem('sessionName', 'zhang')	//保存
localStorage.getItem('sessionName')	//取值
localStorage.removeItem('sessionName')	//删除值
localStorage.clear()	//清除所有
```



### （1）共同点

都是用来保存数据的，保存在浏览器端。



### （2）差异点

1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下；
2. 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大；
3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭；
4. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的；



## 7、BOM属性

BOM是浏览器对象，常用属性：

### （1）location属性

```js
location.href	//返回或设置当前文档的 URL
location.search	//返回 URL 中的查询字符串部分(问号后面的部分)
location.hash	//返回 URL#后面的内容，如果没有#，返回空
location.host	//返回 URL 中的域名部分
location.hostname	//返回 URL 中的主域名部分
location.pathname	//返回 URL 的域名后的部分
location.port	//返回URL中的端口部分
location.protocol	//返回URL中协议部分
location.replace()	//设置当前文档的URL，并且在 history 对象的地址列表中移除这个 URL
location.reload()	//重载当前页面
```



### （2）history对象

```js
history.go() //前进或后退指定的页面数 history.go(num);
history.back() //后退一页
history.forward() //前进一页
```



### （3）navigator对象

```js
navigator.userAgent	//返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)
navigator.cookieEnabled //返回浏览器是否支持(启用)cookie
```



## 8、web worker

### （1）说明

​	JS最初设计是运行在浏览器中的，为了防止多个线程同时操作DOM，带来渲染冲突问题，所以JS执行器被设计成单线程。当遇到需要大量计算的场景时（图像处理、视频解码等），JS线程会被长时间阻塞，甚至造成页面卡顿，影响用户体验。

​	`Web Worker` 是 HTML5 标准的一部分，允许在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，赋予开发者利用 js 操作多线程的能力。因为是独立的线程，Worker 线程与 js 主线程能够同时运行，互不阻塞。



### （2）使用限制

1. 通信限制：worker线程与主线程不在同一个上下文，不能直接通信，需要通过`postMessage`方法来通信；
2. 脚本限制：worker线程不能执行`alert`、`confirm`，但可以使用 `XMLHttpRequest` 对象发出ajax请求；
3. DOM操作限制：worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 `document`、`window`等对象，但是可以获取`navigator`、`location(只读)`、`XMLHttpRequest`、`setTimeout`等浏览器API；
4. 文件限制：worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源；



### （3）使用方法

#### 3.1、创建worker

创建 worker 只需要通过 new 调用 Worker() 构造函数即可

```js
const worker = new Worker(path, options);
```

- path：有效的JS脚本地址，必须遵守同源策略；
- options：配置worker类型、凭证；



#### 3.2、数据传递

主线程与 worker 线程都是通过 postMessage 方法来发送消息，以及监听 message 事件来接收消息

```js
// 主线程
const myWorker = new Worker('/worker.js');
myWorker.addEventListener('message', e => {
  console.log(e.data)	// worker线程发送过来的消息
})
// 也可以使用这种写法
// myWorker.onmessage = e => {
//   console.log(e.data) // 接收消息
// }
myWorker.postMessage('发送消息')	// 向worker线程发送消息，对应worker线程中的e.data
```

```js
// worker线程
self.addEventListener('message', e => {
  console.log(e.data); // 主线程发送的消息
  self.postMessage('发送消息'); // 向主线程发送的消息
});
```



#### 3.3、关闭worker

worker 线程的关闭在主线程和 worker 线程都能进行操作

```js
// 主线程
const myWorker = new Worker("./worker.js")
myWorker.terminate() //关闭worker
```

```js
// worker线程
self.close()
```



## 9、HTML5和CSS3

### （1）HTML5

1. 标签增删

   新增8个语义元素，header、section、footer、aside、nav、main、article、figure；

   新的表单控件，calander、date、time、email、url、search；

   新的 input 类型 color、date、datetime、datetime-local、email；

   移除过时标签 big、font、frame、frameset

2. 支持canvas 绘图，支持内联 SVG。支持 MathML；

3. 多媒体标签 audio、video、source、embed、track；

4. 本地离线存储，把需要离线存储在本地的文件列在一个 manifest 配置文件；

5. 增加web 存储，localStorage、SessionStorage；

6. 增加地理定位API，多线程编程的 web worker 和 websocket 协议等



### （2）CSS3

1. 增加媒体查询；
2. 增加弹性布局flex；
3. 增加边框如 border-radius，box-shadow 等；
4. 增加背景如 background-size，background-origin 等；
5. 增加动画 2D，3D 转换如 transform、animation 等；
6. 增加阴影 text-shadow；
7. 增加渐变 linear-gradient；



## 10、iframe

### （1）定义

​	HTML内联框架元素，表示嵌套的浏览上下文（浏览器展示文档的环境）。够将另一个 HTML 页面嵌入到当前页面中

### （2）缺点

1. 会阻塞主页面onload事件；
2. 搜索引擎无法读取，不利于SEO；
3. iframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能；



## 11、Doctype 作用

Doctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。

- 严格模式

  排版和 JS 运作模式是以该浏览器支持的最高标准运行

- 混杂模式

  向后兼容，模拟老式浏览器，防止浏览器无法兼容页面



## 12、XSS和CSRF攻击和防范

### （1）XSS

#### 1.1、定义

XSS即跨站脚本攻击，攻击者通过在目标网站注入恶意脚本，在用户浏览网页的时候进行攻击，获取 cookie，或者其他用户身份信息。

可以分为存储型和反射型：

- 存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击；
- 反射型的话不存储在数据库中，往往表现为将攻击代码放在 url 地址的请求参数中；



#### 1.2、常用攻击方法

1. 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入；
2. 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签；
3. 在标签的 href、src 等属性中，包含 `javascript:` 等可执行代码；
4. 在 onload、onerror、onclick 等事件中，注入不受控制代码；



#### 1.3、防范手段

1. 输入过滤；

2. 纯前端渲染，把代码和数据分隔开；

3. 对 HTML 做充分转义；

4. 避免js在字符串中拼接不可信数据；

5. 输入内容长度控制；

6. 在HTTP头部上配置`set-cookie`，设置两个属性：

   httponly：该属性可禁止JavaScript访问Cookie，故可以保护Cookie不被嵌入的恶意代码所获取；

   secure：该属性告诉客户端浏览器仅当在https请求时发送Cookie；



### （2）CSRF

#### 2.1、定义

CSRF即跨站请求伪造，黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求比如用户登录了一个网站后，立刻访问另一个攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候 CSRF 就产生了。



#### 2.2、常用攻击方法

1. 自动发起Get请求，比如在图片中隐藏转账请求接口，加载图片时自动发起请求；
2. 自动发起Post请求，黑客站点伪造POST请求，当用户打开站点时会自动提交 POST 请求；
3. 引诱用户点击链接，常见就是各种邮件链接等；



#### 2.3、防范手段

1. 同源检测，禁止外域（或者不受信任的域名）发起请求，检查HTTP请求头中的Referer（记录Http请求的来源地址值）和Origin属性；
2. 设置Token，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息，因此要求所有的用户请求都携带一个Token，服务器通过校验Token区分请求；
3. 使用验证码；



## 13、RESTFUL

​	REST是Web服务的一种新的架构风格（一种思想）。RESTful是一种常见的REST应用，是遵循REST风格的web服务，REST式的web服务是一种ROA（面向资源的架构）。

### （1）RESTful风格主要原则

- 对网络上所有的资源都有一个资源标志符；
- 对资源的操作不会改变标识符；
- 同一资源有多种表现形式；
- 所有操作都是无状态的；

### （2）REST资源操作

| http方法 | 资源操作 | 幂等 | 安全 |
| -------- | -------- | ---- | ---- |
| GET      | SELECT   | 是   | 是   |
| POST     | INSERT   | 否   | 否   |
| PUT      | UPDATE   | 是   | 否   |
| DELETE   | DELETE   | 是   | 否   |

RESTful中根据操作资源的不同，使用不同的http方法，其传输的媒介一般使用json

### （3）接口案例

```js
// 传统URL
http://127.0.0.1/user/query/1 GET 根据用户id查询用户数据
http://127.0.0.1/user/save POST 新增用户
http://127.0.0.1/user/update POST 修改用户信息
http://127.0.0.1/user/delete GET/POST 删除用户信息
```

```js
// RESTful
http://127.0.0.1/user/{id} GET 根据用户id查询用户数据
http://127.0.0.1/user POST 新增用户
http://127.0.0.1/user PUT 修改用户信息
http://127.0.0.1/user DELETE 删除用户信息  OR http://127.0.0.1/user/{id} DELETE 删除用户信息
```



## 14、addEventListener

语法：`addEventListener(event, function, useCapture)`

参数：

- event 指定事件名；
- function 指定要事件触发时执行的函数；
- useCapture 指定事件是否在捕获或冒泡阶段执行，true在捕获阶段处理，false在冒泡阶段处理；



## 15、http请求头

| 协议头            | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| Accept            | 可接受的响应内容类型                                         |
| Accept-Charset    | 可接受的字符集                                               |
| Accept-Encoding   | 可接受的响应内容的编码方式                                   |
| Authorization     | HTTP 协议中需要认证资源的认证信息                            |
| Cache-Control     | 指定当前的请求/回复中是否使用缓存机制                        |
| Connection        | 客户端(浏览器)想要优先使用的连接类型                         |
| Cookie            | 由之前服务器通过Set-Cooki设置的一个HTTP协议Cookie            |
| Content-Type      | 请求体的 MIME 类型 (用于 POST 和 PUT 请求中)                 |
| Host              | 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口 是对应的服务的标准端口(80)，则端口号可以省略 |
| If-Modified-Since | 允许在对应的资源未被修改的情况下返回 304 未修改              |



## 16、强/协商缓存

http缓存分为强缓存和协商缓存

| 缓存类型 | 获取资源形式 | 状态码 | 发送请求                         |
| -------- | ------------ | ------ | -------------------------------- |
| 强缓存   | 从缓存中获取 | 200    | 否，直接从缓存取                 |
| 协商缓存 | 从缓存中获取 | 304    | 是，通过服务器来告知缓存是否可用 |

强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话， cache-control 的优先级高于 expires。
协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match。



## 17、get和post区别

1. get参数通过url传递，post放在request body中；
2. get请求在 url 中传递的参数是有长度限制的，而 post 没有；
3. get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息；
4. get 请求只能进行 url 编码，而 post 支持多种编码方式；
5. get 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留；
6. GET 和 POST 本质上就是 TCP 链接，但是由于 HTTP 的规定和浏览器/服务器的限制，导致GET 产生一个 TCP 数据包，而POST 产生两个 TCP 数据包；



## 18、状态301和302区别

​	301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
​	302 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的， 客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。
​	总结：301 是永久重定向，而 302 是临时重定向。 301比较常用的场景是使用域名跳转。302用来做临时跳转比如未登陆的用户访问用户中心，重定向到登录页面。



## 19、绘制三角形

```css
.trangle {
  width: 0px;
  height: 0px;
  border-top: 10px solid red;
  border-right: 10px solid transparent;
  border-bottom: 10px solid transparent;
  border-left: 10px solid transparent;
}
```



## 20、从URL到页面展示过程

### （1）用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的是关键字是搜索内容还是请求的URL。

### （2）URL请求过程

​	网络进程会查找本地缓存是否缓存了请求资源，如果有就直接返回给浏览器进程；如果没有就直接进入网络请求流程。

​	请求会进行DNS解析，以获取请求域名对应的服务器IP地址。如果请求是HTTPS协议，那么还需要建立TLS连接。

​	利用IP地址和服务器建立TCP连接，连接建立后浏览器构建请求行、请求头信息，把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。

​	服务器收到请求信息后，根据请求信息生成响应数据（包括响应行、相应头和响应体信息）发送给网络进程。

​	网络进程收到响应行和响应头之后，开始解析响应头的内容。返回状态码是301或302重定向时，网络进程会从响应头Location字段取出重定向地址，重新发起HTTP或HTTPS请求。浏览器通过响应头中的Content-Type字段判断响应体数据类型，根据具体的值来显示。

### （3）准备渲染过程

浏览器默认给每个页面开启一个渲染进程，渲染进程准备好之后，请求回来的文档数据还在网络进程中，并没有提交给渲染进程。

### 	（4）提交文档过程

浏览器进程将网络进程收到的HTML数据提交给渲染进程

### （5）渲染过程

渲染流程包括：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成这几部分。

#### 5.1、构建DOM

将HTML 文件经由 HTML 解析器解析，输出树状结构的 DOM 对象；

#### 5.2、样式计算

1. 将 CSS 文本转换为浏览器可以理解的结构styleSheets，该结构具备查询和修改功能；
2. 将所有样式表值转换为渲染引擎容易理解的、标准化的计算值；
3. 应用css的继承和层叠规则，给DOM树每个节点绑定样式属性；

#### 5.3、布局阶段

1. 创建布局树，该树结构只包含可见元素；
2. 布局计算，计算可见元素样式等；

#### 5.4、分层

为了实现一些复杂的效果，比如3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等。渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。图层叠加后合成了最终的页面。

#### 5.5、栅格化操作

合成线程将图层分成图块，然后将图块转换为位图；

#### 5.6、合成和展示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令提交给浏览器进程，浏览器进程接受命令后将页面内容绘制到内存中，显示在屏幕上。

#### 5.7、渲染总结

- 渲染进程把HTML内容转换成DOM树结构
- 渲染引擎把CSS转换成styleSheet，计算DOM节点样式；
- 创建布局树，计算绑定布局样式信息；
- 对布局树分层，生成分层树；
- 对每个图层生成绘制列表，交给合成线程；
- 合成线程把图层分层成图块，在光栅化线程池将图块转化成位图；
- 合成线程发送绘图指令给浏览器进程；
- 浏览器进程根据指令生成页面，显示在显示器上



## 21、网站性能测试

检测页面加载时间一般有两种方式：

1. 被动监测

   在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析；

2. 主动监测

   主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数 据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极客



## 22、盒子模型

1. IE盒模型：

   width的宽度包含 border + padding + content

2. W3C标准盒模型：

   width的宽度包含 content



## 23、画0.5px的线

### （1）移动端使用meta viewport方式

缩放到原来的0.5倍，1px就是0.5px

```html
<meta name="viewport" 
	content="width=device-width, 
	initial-scale=0.5, 
  minimum-scale=0.5,
  maximum-scale=0.5"/>
```



### （2）使用transform: scale()方式

```css
transform: scale(0.5, 0.5)
```



### （3）使用box-shadow

设置box-shadow的第二个参数为0.5px，表示阴影垂直方向的偏移为0.5px

```css
height: 1px;
background: none;
box-shadow: 0 0.5px 0 #000
```



## 24、link和@import

css的引入方式有两种，link标签和@import引入。

### 区别

1. link是 HTML 提供的标签，不仅可以加载CSS文件，还可以定义rel连接属性；@import是CSS提供的语法规则，只有导入样式表的作用；
2. 加载页面时，`link`标签引入的 CSS 被同时加载；`@import`引入的 CSS 将在页面加载完毕后被加载；
3. `@import`是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；`link`标签作为 HTML 元素，不存在兼容性问题；
4. `link`引入的样式权重大于`@import`引入的样式；



## 25、transition和animation

### （1）transition

该属性是一个简写属性，表示过渡、转变的意思。用于设置四个过渡属性。

- transition-property：设置过渡效果的属性名称（默认值是all）；
- transition-duration：设置过渡完成所需要的时间（默认值是0）；
- transition-timing-function：设置过渡速度效果曲线（默认值是ease）；
- transition-delay：设置过渡的开始时间（默认值是0）；



### （2）animation

该属性是一个简写属性，通过关键帧实现动画效果，用于设置六个动画属性。

- animation-name：设置绑定到选择器的@keyframem名称（默认值是none）；
- animation-duration：设置完成动画所花费的时间（默认值是0）；
- animation-timing-function：设置动画的速度曲线（默认值是ease）；
- animation-delay：设置动画延迟几秒开始（默认值是0）；
- animation-iteration-count：设置动画播放的次数（默认值是1）；
- animation-direction：设置时候轮流反向播放动画（默认值是normal）；



### （3）区别

transition是一个过渡效果，没有中间状态，需要设置触发事件才能执行；

animation是一个动画的效果，有多个关键帧，可以在任意一个中间帧设置状态，不需要设置触发事件就能执行；



## 26、flex布局

弹性布局用来为盒模型提供最大的灵活性。

### （1）容器属性

- 决定主轴方向

```css
flex-direction: row | row-reverse | column | column-reverse;
```

- 决定轴线排列方向，如何换行

```css
flex-wrap: nowrap | wrap | wrap-reverse;
```

- direction和wrap的简写

```css
flex-flow: <flex-direction> || <flex-wrap>;
```

- 决定水平对齐方式

```css
justify-content: flex-start | flex-end | center | space-between | space-around;
```

- 决定垂直对齐方式

```css
align-items: flex-start | flex-end | center | baseline | stretch;
```

- 多轴线的对齐方式

```css
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
```



### （2）项目属性

- 定义项目的排列顺序。数值越小，排列越靠前，默认为0

```css
order: <integer>;
```

- 放大比例

```css
flex-grow: <number>;
```

- 缩小比例

```css
flex-shrink: <number>;
```

- `flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为0 1 auto。后两个属性可选

```css
flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
```



## 27、BFC

### （1）定义

块级格式上下文，是一个独立的渲染区域，有一定的布局规划，与区域外外部毫不相干。



### （2）特征

1. BFC是一个独立的容器，容器内子元素不会影响容器外的元素，反之亦是如此；
2. 盒子从顶端开始垂直的一个一个的排列，盒子之间垂直的间距是由margin决定的；
3. 在同一个BFC中，两个相邻的块级盒子的垂直外边距会发生重叠；
4. BFC区域不会和float box发生重叠；
5. BFC能够识别并包含浮动元素，当计算其区域的高度时，浮动元素也可以参与计算；



### （3）产生条件

- float的值不为none；
- position的值不为static或者relative；
- display的值是inline-block、table-cell、flex、table-caption或者inline-flex；
- overflow的值不为visible；



### （4）作用

1. 解决高度坍塌问题；
2. 清除内部浮动；
3. 自适应多栏布局；



## 28、垂直居中方法

### （1）margin:auto

```css
.parent {
  position: relative;
  width: 500px;
  height: 400px;
  background: blue;
}
.child {
  background: red;
  width: 50px;
  height: 50px;
  position: absolute;
  top: 0px;
  bottom: 0px;
  left: 0px;
  right: 0px;
  margin: auto;
}
```



### （2）margin负值/translate偏移

```css
.div2 {
  width: 500px;
  height: 400px;
  position: relative;
}

.span2 {
  width: 180px;
  height: 80px;
  background-color: #746;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```



### （3）利用flex

```css
.div4 {
  width: 300px;
  height: 200px;
  background: black;
  display: flex;
  align-items: center;
  justify-content: center;
}
.span4 {
  width: 50px;
  height: 50px;
  background: red;
}
```



### （4）line-height

```css
.div5 {
  width: 300px;
  height: 200px;
  border: 1px solid #546461;
  font-size: 0px;
  text-align: center;
  line-height: 200px;
}
.span5 {
  display: inline-block;
  width: 100px;
  height: 50px;
  font-size: 16px;
  background-color: red;
  line-height: 50px;
  vertical-align: middle;
}
```



## 29、JS动画和CSS3动画

### （1）JS动画

- 优点：
  - JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的；
  - 动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成；
  - CSS3有兼容性问题，而JS大多时候没有兼容性问题；
- 缺点
  - js是单线程的脚本语言，当js在浏览器主线程运行时，主线程还有其他需要运行的js脚本、样式、计算、布局、交互等一系列任务，对其干扰线程可能出现阻塞，造成丢帧的情况；
  - js在做动画的时候，其复杂度是高于css3的，需要考虑一些计算，操作等方便问题；



### （2）CSS3动画

- 优点
  - 浏览器可以对动画进行优化；
  - 代码相对简单,性能调优方向固定；
  - 对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码；
- 缺点
  - 代码冗长。如果想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重；
  - 运行过程控制较弱，无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告；



## 30、块元素和行内元素

### （1）块元素

独占一行，并且自动填满父元素，可以设置 margin 和 pading 以及高度和宽度，可以包含行内元素和块元素；

常见的有：`div p h1-h6 ul ol li tr td hr`



### （2）行内元素

不会独占一行，width 和 height 会失效，并且在垂直方向的 padding 和 margin 会失效，只能包含行内元素或文字；

常见的有：`span img a input i select strong`



## 31、多行元素的文本省略号

```css
display: -webkit-box;
overflow: hidden;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
width: 100px;
```



## 32、元素隐藏

### （1）visibility=hidden

该元素隐藏起来但是不会改变页面布局，不会触发该元素已经绑定的事件；

### （2）opacity=0

把元素隐藏起来，不会改变页面布局，如果元素绑定了事件（比如点击事件），那么点击该区域也能触发点击事件；

### （3）display:none

把元素隐藏起来，并且会改变页面布局，可以理解为在页面中删除元素；



## 33、双边距重叠问题

多个相邻（兄弟或者父子关系）普通流的块元素垂直方向margin会重叠；

折叠结果为：

1. 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大值；
2. 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；
3. 两个边距一正一负时，折叠结果是两者相加的和；



## 34、position



## 99、响应式原理

当`render`渲染该数据时，出发getter进行依赖收集，收集依赖的目的是将观察者watcher放到当前订阅者Dep的管理下形成一种关联关系。

当修改值的时候，会触发setter，setter会通知订阅者Dep中收集到的watcher依赖值发生改变，需要重新渲染视图，watcher调用update函数更新视图，update中包含patch的过程（diff算法、队列异步更新）
