# HTTP/HTML/浏览器

## 1、http/https

### （1）http和https基本概念

http：超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

https：以安全为目标的 HTTP 通道，是 HTTP 的安全版，HTTPS 的 SSL 加密是在传输层实现的。 HTTPS 协议的主要作用是建立一个信息安全通道，来确保数据的传输和网站的真实性。



### （2）http和https区别

http 传输的数据都是未加密的，也就是明文的。简单来说 https 协议是由 http 和 ssl 协议构建的可进行加密传 输和身份认证的网络协议，比 http 协议的安全性更高。

- https 协议需要 ca 证书，费用较高。
- http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。 使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443
- http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。



### （3）https协议工作原理

客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，

1. 客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。
2. web 服务器接收到客户端的请求之后，会将网站的证书(证书中包含了公钥)，返回给客户端。
3. 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加 密会话密钥，并传送给网站。
4.  web 服务器通过自己的私钥解密出会话密钥。
5.  web 服务器通过会话密钥加密与客户端之间的通信。



### （4）https协议优缺点

#### 优点：

1. 可以认证用户和服务器，确保数据发送到正确的客户机和服务器；
2. HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；
3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本；

#### 缺点：

1. https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电；
2. https 缓存不如 http 高效，会增加数据开销；
3. SSL 证书也需要钱，功能越强大的证书费用越高；
4. SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗；



## 2、TCP和UDP的区别

1. TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接；
2. TCP提供可靠的服务，传送数据无差错、不丢失、不重复且按序到达，适合大数据量的交换；UDP尽最大努力交付，但是不保证可靠；
3. TCP面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低，适合IP电话和视频会议等；
4. TCP只能是1对1对，UDP支持1对1，1对多；
5. TCP首部较大，为20字节，UDP只有8字节；
6. TCP 是面向连接的可靠性传输，而 UDP 是不可靠的；



## 3、http发展

### （1）HTTP/1

#### 1.1、HTTP/0.9

1991年提出，用来在网络之间传递HTML超文本内容。

特点：只有一个请求行，没有请求头和请求体；没有返回头；返回的文件内容以ASCII字符流来传输。



#### 1.2、HTTP/1.0

万维网的发展推动新协议的要求。

特点：增加请求头告诉服务器期待返回的文件类型、压缩形式和编码格式；增加了响应头和响应体来支持不同类型的数据；引入状态码；提供缓存机制；增加了用户代理字段；



#### 1.3、HTTP/1.1

特点：增加了持久连接的方法，在请求头和相应头中添加`Connection: Keep-Alive`保证连接不中断；提供虚拟主机的支持；对动态生成的内容提供了完美支持；客户端增加cookie和安全机制；



### （2）HTTP/2

特点：

1. 增加二进制分帧层：会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码，转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器；
2. 多路复用：当收到一个优先级高的请求时，服务器可以暂停之前的请求来优先处理关键资源的请求，然后根据 ID 编号将帧的数据返回给对应的请求，最后将所有相同ID的帧合并为一条完整的信息；
3. 可以设置请求的优先级；
4. 头部压缩：对请求头和相应头进行了压缩，提升了大量请求时的传输效率；
5. 服务器推送：可以直接将数据提前推送到浏览器；



## 4、状态码

| 状态码 | 说明                                                         |
| :----- | ------------------------------------------------------------ |
| 200    | 客户端请求成功                                               |
| 201    | 请求成功，通常是POST请求创建了一个新资源                     |
| 301    | 请求资源URL永久更改，响应中会给出新URL                       |
| 302    | 请求资源URL临时更改，应该在将来的请求中继续使用相同的URL     |
| 304    | 使用缓存，和上次响应比没有被修改，可以继续使用相同的缓存     |
| 400    | 客户端有语法错误，服务器无法或不进行处理（常见的传参错误，没有和后台要求保持一致） |
| 401    | 未授权错误，客户端必须携带身份信息，提供身份验证才能获得请求响应 |
| 403    | 客户端知道身份信息，但是没有权限访问，拒绝提供服务           |
| 404    | 服务器找不到请求资源（输入错误的URL）                        |
| 500    | 服务器遇到不可预期的错误                                     |
| 503    | 服务器不可用，可能处于维护或者重载状态，暂时无法访问         |



## 5、fetch请求发送2次

fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功：

用 fetch 的 post 请求的时候，导致 fetch 第一次发送了一个 Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。





## 6、Cookie、sessionStorage和localStorage

### （1）共同点

都是用来保存数据的，保存在浏览器端，并且是同源的。

### （2）差异点

#### Cookie

cookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径(path)的概念，可以限制 cookie 只属于某个路径下, 存储的大小很小只有4K 左右。

cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭

#### sessionStorage

仅在当前浏览器窗口关闭前有效，关闭浏览器后消失。多窗口之间sessionStorage不可以共享状态，但是在某些特定场景下（在本页面中以新页签或窗口打开的同源页面）新开的页面会复制之前页面的sessionStorage。



#### localStorage

localStorage: 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据。localStorage 在所有同源窗口中都是共享的;cookie 也是在所有同源窗口中 都是共享的。(key:同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与 否都会始终生效)



## 5、BOM属性

BOM是浏览器对象，常用属性：

### （1）location属性

```js
location.href	//返回或设置当前文档的 URL
location.search	//返回 URL 中的查询字符串部分(问号后面的部分)
location.hash	//返回 URL#后面的内容，如果没有#，返回空
location.host	//返回 URL 中的域名部分
location.hostname	//返回 URL 中的主域名部分
location.pathname	//返回 URL 的域名后的部分
location.port	//返回URL中的端口部分
location.protocol	//返回URL中协议部分
location.replace()	//设置当前文档的URL，并且在 history 对象的地址列表中移除这个 URL
location.reload()	//重载当前页面
```



### （2）history对象

```js
history.go() //前进或后退指定的页面数 history.go(num);
history.back() //后退一页
history.forward() //前进一页
```



### （3）navigator对象

```js
navigator.userAgent	//返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)
navigator.cookieEnabled //返回浏览器是否支持(启用)cookie
```





响应式原理

当`render`渲染该数据时，出发getter进行依赖收集，收集依赖的目的是将观察者watcher放到当前订阅者Dep的管理下形成一种关联关系。

当修改值的时候，会触发setter，setter会通知订阅者Dep中收集到的watcher依赖值发生改变，需要重新渲染视图，watcher调用update函数更新视图，update中包含patch的过程（diff算法、队列异步更新）
